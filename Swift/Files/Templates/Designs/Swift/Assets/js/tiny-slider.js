/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./Swift/Files/Templates/Designs/Swift/Assets/_src/js/modules/tiny-slider.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./Swift/Files/Templates/Designs/Swift/Assets/_src/js/modules/tiny-slider.js":
/*!***********************************************************************************!*\
  !*** ./Swift/Files/Templates/Designs/Swift/Assets/_src/js/modules/tiny-slider.js ***!
  \***********************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tiny_slider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tiny-slider */ \"./node_modules/tiny-slider/dist/tiny-slider.js\");\n/* harmony import */ var tiny_slider__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tiny_slider__WEBPACK_IMPORTED_MODULE_0__);\n\nwindow.tns = tiny_slider__WEBPACK_IMPORTED_MODULE_0__[\"tns\"];\n\n//# sourceURL=webpack:///./Swift/Files/Templates/Designs/Swift/Assets/_src/js/modules/tiny-slider.js?");

/***/ }),

/***/ "./node_modules/tiny-slider/dist/tiny-slider.js":
/*!******************************************************!*\
  !*** ./node_modules/tiny-slider/dist/tiny-slider.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var tns = function () {\n  var win = window;\n\n  var raf = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.msRequestAnimationFrame || function (cb) {\n    return setTimeout(cb, 16);\n  };\n\n  var win$1 = window;\n\n  var caf = win$1.cancelAnimationFrame || win$1.mozCancelAnimationFrame || function (id) {\n    clearTimeout(id);\n  };\n\n  function extend() {\n    var obj,\n        name,\n        copy,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length;\n\n    for (; i < length; i++) {\n      if ((obj = arguments[i]) !== null) {\n        for (name in obj) {\n          copy = obj[name];\n\n          if (target === copy) {\n            continue;\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    }\n\n    return target;\n  }\n\n  function checkStorageValue(value) {\n    return ['true', 'false'].indexOf(value) >= 0 ? JSON.parse(value) : value;\n  }\n\n  function setLocalStorage(storage, key, value, access) {\n    if (access) {\n      try {\n        storage.setItem(key, value);\n      } catch (e) {}\n    }\n\n    return value;\n  }\n\n  function getSlideId() {\n    var id = window.tnsId;\n    window.tnsId = !id ? 1 : id + 1;\n    return 'tns' + window.tnsId;\n  }\n\n  function getBody() {\n    var doc = document,\n        body = doc.body;\n\n    if (!body) {\n      body = doc.createElement('body');\n      body.fake = true;\n    }\n\n    return body;\n  }\n\n  var docElement = document.documentElement;\n\n  function setFakeBody(body) {\n    var docOverflow = '';\n\n    if (body.fake) {\n      docOverflow = docElement.style.overflow; //avoid crashing IE8, if background image is used\n\n      body.style.background = ''; //Safari 5.13/5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible\n\n      body.style.overflow = docElement.style.overflow = 'hidden';\n      docElement.appendChild(body);\n    }\n\n    return docOverflow;\n  }\n\n  function resetFakeBody(body, docOverflow) {\n    if (body.fake) {\n      body.remove();\n      docElement.style.overflow = docOverflow; // Trigger layout so kinetic scrolling isn't disabled in iOS6+\n      // eslint-disable-next-line\n\n      docElement.offsetHeight;\n    }\n  } // get css-calc \n\n\n  function calc() {\n    var doc = document,\n        body = getBody(),\n        docOverflow = setFakeBody(body),\n        div = doc.createElement('div'),\n        result = false;\n    body.appendChild(div);\n\n    try {\n      var str = '(10px * 10)',\n          vals = ['calc' + str, '-moz-calc' + str, '-webkit-calc' + str],\n          val;\n\n      for (var i = 0; i < 3; i++) {\n        val = vals[i];\n        div.style.width = val;\n\n        if (div.offsetWidth === 100) {\n          result = val.replace(str, '');\n          break;\n        }\n      }\n    } catch (e) {}\n\n    body.fake ? resetFakeBody(body, docOverflow) : div.remove();\n    return result;\n  } // get subpixel support value\n\n\n  function percentageLayout() {\n    // check subpixel layout supporting\n    var doc = document,\n        body = getBody(),\n        docOverflow = setFakeBody(body),\n        wrapper = doc.createElement('div'),\n        outer = doc.createElement('div'),\n        str = '',\n        count = 70,\n        perPage = 3,\n        supported = false;\n    wrapper.className = \"tns-t-subp2\";\n    outer.className = \"tns-t-ct\";\n\n    for (var i = 0; i < count; i++) {\n      str += '<div></div>';\n    }\n\n    outer.innerHTML = str;\n    wrapper.appendChild(outer);\n    body.appendChild(wrapper);\n    supported = Math.abs(wrapper.getBoundingClientRect().left - outer.children[count - perPage].getBoundingClientRect().left) < 2;\n    body.fake ? resetFakeBody(body, docOverflow) : wrapper.remove();\n    return supported;\n  }\n\n  function mediaquerySupport() {\n    if (window.matchMedia || window.msMatchMedia) {\n      return true;\n    }\n\n    var doc = document,\n        body = getBody(),\n        docOverflow = setFakeBody(body),\n        div = doc.createElement('div'),\n        style = doc.createElement('style'),\n        rule = '@media all and (min-width:1px){.tns-mq-test{position:absolute}}',\n        position;\n    style.type = 'text/css';\n    div.className = 'tns-mq-test';\n    body.appendChild(style);\n    body.appendChild(div);\n\n    if (style.styleSheet) {\n      style.styleSheet.cssText = rule;\n    } else {\n      style.appendChild(doc.createTextNode(rule));\n    }\n\n    position = window.getComputedStyle ? window.getComputedStyle(div).position : div.currentStyle['position'];\n    body.fake ? resetFakeBody(body, docOverflow) : div.remove();\n    return position === \"absolute\";\n  } // create and append style sheet\n\n\n  function createStyleSheet(media, nonce) {\n    // Create the <style> tag\n    var style = document.createElement(\"style\"); // style.setAttribute(\"type\", \"text/css\");\n    // Add a media (and/or media query) here if you'd like!\n    // style.setAttribute(\"media\", \"screen\")\n    // style.setAttribute(\"media\", \"only screen and (max-width : 1024px)\")\n\n    if (media) {\n      style.setAttribute(\"media\", media);\n    } // Add nonce attribute for Content Security Policy\n\n\n    if (nonce) {\n      style.setAttribute(\"nonce\", nonce);\n    } // WebKit hack :(\n    // style.appendChild(document.createTextNode(\"\"));\n    // Add the <style> element to the page\n\n\n    document.querySelector('head').appendChild(style);\n    return style.sheet ? style.sheet : style.styleSheet;\n  } // cross browsers addRule method\n\n\n  function addCSSRule(sheet, selector, rules, index) {\n    // return raf(function() {\n    'insertRule' in sheet ? sheet.insertRule(selector + '{' + rules + '}', index) : sheet.addRule(selector, rules, index); // });\n  } // cross browsers addRule method\n\n\n  function removeCSSRule(sheet, index) {\n    // return raf(function() {\n    'deleteRule' in sheet ? sheet.deleteRule(index) : sheet.removeRule(index); // });\n  }\n\n  function getCssRulesLength(sheet) {\n    var rule = 'insertRule' in sheet ? sheet.cssRules : sheet.rules;\n    return rule.length;\n  }\n\n  function toDegree(y, x) {\n    return Math.atan2(y, x) * (180 / Math.PI);\n  }\n\n  function getTouchDirection(angle, range) {\n    var direction = false,\n        gap = Math.abs(90 - Math.abs(angle));\n\n    if (gap >= 90 - range) {\n      direction = 'horizontal';\n    } else if (gap <= range) {\n      direction = 'vertical';\n    }\n\n    return direction;\n  } // https://toddmotto.com/ditch-the-array-foreach-call-nodelist-hack/\n\n\n  function forEach(arr, callback, scope) {\n    for (var i = 0, l = arr.length; i < l; i++) {\n      callback.call(scope, arr[i], i);\n    }\n  }\n\n  var classListSupport = ('classList' in document.createElement('_'));\n  var hasClass = classListSupport ? function (el, str) {\n    return el.classList.contains(str);\n  } : function (el, str) {\n    return el.className.indexOf(str) >= 0;\n  };\n  var addClass = classListSupport ? function (el, str) {\n    if (!hasClass(el, str)) {\n      el.classList.add(str);\n    }\n  } : function (el, str) {\n    if (!hasClass(el, str)) {\n      el.className += ' ' + str;\n    }\n  };\n  var removeClass = classListSupport ? function (el, str) {\n    if (hasClass(el, str)) {\n      el.classList.remove(str);\n    }\n  } : function (el, str) {\n    if (hasClass(el, str)) {\n      el.className = el.className.replace(str, '');\n    }\n  };\n\n  function hasAttr(el, attr) {\n    return el.hasAttribute(attr);\n  }\n\n  function getAttr(el, attr) {\n    return el.getAttribute(attr);\n  }\n\n  function isNodeList(el) {\n    // Only NodeList has the \"item()\" function\n    return typeof el.item !== \"undefined\";\n  }\n\n  function setAttrs(els, attrs) {\n    els = isNodeList(els) || els instanceof Array ? els : [els];\n\n    if (Object.prototype.toString.call(attrs) !== '[object Object]') {\n      return;\n    }\n\n    for (var i = els.length; i--;) {\n      for (var key in attrs) {\n        els[i].setAttribute(key, attrs[key]);\n      }\n    }\n  }\n\n  function removeAttrs(els, attrs) {\n    els = isNodeList(els) || els instanceof Array ? els : [els];\n    attrs = attrs instanceof Array ? attrs : [attrs];\n    var attrLength = attrs.length;\n\n    for (var i = els.length; i--;) {\n      for (var j = attrLength; j--;) {\n        els[i].removeAttribute(attrs[j]);\n      }\n    }\n  }\n\n  function arrayFromNodeList(nl) {\n    var arr = [];\n\n    for (var i = 0, l = nl.length; i < l; i++) {\n      arr.push(nl[i]);\n    }\n\n    return arr;\n  }\n\n  function hideElement(el, forceHide) {\n    if (el.style.display !== 'none') {\n      el.style.display = 'none';\n    }\n  }\n\n  function showElement(el, forceHide) {\n    if (el.style.display === 'none') {\n      el.style.display = '';\n    }\n  }\n\n  function isVisible(el) {\n    return window.getComputedStyle(el).display !== 'none';\n  }\n\n  function whichProperty(props) {\n    if (typeof props === 'string') {\n      var arr = [props],\n          Props = props.charAt(0).toUpperCase() + props.substr(1),\n          prefixes = ['Webkit', 'Moz', 'ms', 'O'];\n      prefixes.forEach(function (prefix) {\n        if (prefix !== 'ms' || props === 'transform') {\n          arr.push(prefix + Props);\n        }\n      });\n      props = arr;\n    }\n\n    var el = document.createElement('fakeelement'),\n        len = props.length;\n\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n\n      if (el.style[prop] !== undefined) {\n        return prop;\n      }\n    }\n\n    return false; // explicit for ie9-\n  }\n\n  function has3DTransforms(tf) {\n    if (!tf) {\n      return false;\n    }\n\n    if (!window.getComputedStyle) {\n      return false;\n    }\n\n    var doc = document,\n        body = getBody(),\n        docOverflow = setFakeBody(body),\n        el = doc.createElement('p'),\n        has3d,\n        cssTF = tf.length > 9 ? '-' + tf.slice(0, -9).toLowerCase() + '-' : '';\n    cssTF += 'transform'; // Add it to the body to get the computed style\n\n    body.insertBefore(el, null);\n    el.style[tf] = 'translate3d(1px,1px,1px)';\n    has3d = window.getComputedStyle(el).getPropertyValue(cssTF);\n    body.fake ? resetFakeBody(body, docOverflow) : el.remove();\n    return has3d !== undefined && has3d.length > 0 && has3d !== \"none\";\n  } // get transitionend, animationend based on transitionDuration\n  // @propin: string\n  // @propOut: string, first-letter uppercase\n  // Usage: getEndProperty('WebkitTransitionDuration', 'Transition') => webkitTransitionEnd\n\n\n  function getEndProperty(propIn, propOut) {\n    var endProp = false;\n\n    if (/^Webkit/.test(propIn)) {\n      endProp = 'webkit' + propOut + 'End';\n    } else if (/^O/.test(propIn)) {\n      endProp = 'o' + propOut + 'End';\n    } else if (propIn) {\n      endProp = propOut.toLowerCase() + 'end';\n    }\n\n    return endProp;\n  } // Test via a getter in the options object to see if the passive property is accessed\n\n\n  var supportsPassive = false;\n\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function () {\n        supportsPassive = true;\n      }\n    });\n    window.addEventListener(\"test\", null, opts);\n  } catch (e) {}\n\n  var passiveOption = supportsPassive ? {\n    passive: true\n  } : false;\n\n  function addEvents(el, obj, preventScrolling) {\n    for (var prop in obj) {\n      var option = ['touchstart', 'touchmove'].indexOf(prop) >= 0 && !preventScrolling ? passiveOption : false;\n      el.addEventListener(prop, obj[prop], option);\n    }\n  }\n\n  function removeEvents(el, obj) {\n    for (var prop in obj) {\n      var option = ['touchstart', 'touchmove'].indexOf(prop) >= 0 ? passiveOption : false;\n      el.removeEventListener(prop, obj[prop], option);\n    }\n  }\n\n  function Events() {\n    return {\n      topics: {},\n      on: function (eventName, fn) {\n        this.topics[eventName] = this.topics[eventName] || [];\n        this.topics[eventName].push(fn);\n      },\n      off: function (eventName, fn) {\n        if (this.topics[eventName]) {\n          for (var i = 0; i < this.topics[eventName].length; i++) {\n            if (this.topics[eventName][i] === fn) {\n              this.topics[eventName].splice(i, 1);\n              break;\n            }\n          }\n        }\n      },\n      emit: function (eventName, data) {\n        data.type = eventName;\n\n        if (this.topics[eventName]) {\n          this.topics[eventName].forEach(function (fn) {\n            fn(data, eventName);\n          });\n        }\n      }\n    };\n  }\n\n  function jsTransform(element, attr, prefix, postfix, to, duration, callback) {\n    var tick = Math.min(duration, 10),\n        unit = to.indexOf('%') >= 0 ? '%' : 'px',\n        to = to.replace(unit, ''),\n        from = Number(element.style[attr].replace(prefix, '').replace(postfix, '').replace(unit, '')),\n        positionTick = (to - from) / duration * tick,\n        running;\n    setTimeout(moveElement, tick);\n\n    function moveElement() {\n      duration -= tick;\n      from += positionTick;\n      element.style[attr] = prefix + from + unit + postfix;\n\n      if (duration > 0) {\n        setTimeout(moveElement, tick);\n      } else {\n        callback();\n      }\n    }\n  } // Object.keys\n\n\n  if (!Object.keys) {\n    Object.keys = function (object) {\n      var keys = [];\n\n      for (var name in object) {\n        if (Object.prototype.hasOwnProperty.call(object, name)) {\n          keys.push(name);\n        }\n      }\n\n      return keys;\n    };\n  } // ChildNode.remove\n\n\n  if (!(\"remove\" in Element.prototype)) {\n    Element.prototype.remove = function () {\n      if (this.parentNode) {\n        this.parentNode.removeChild(this);\n      }\n    };\n  }\n\n  var tns = function (options) {\n    options = extend({\n      container: '.slider',\n      mode: 'carousel',\n      axis: 'horizontal',\n      items: 1,\n      gutter: 0,\n      edgePadding: 0,\n      fixedWidth: false,\n      autoWidth: false,\n      viewportMax: false,\n      slideBy: 1,\n      center: false,\n      controls: true,\n      controlsPosition: 'top',\n      controlsText: ['prev', 'next'],\n      controlsContainer: false,\n      prevButton: false,\n      nextButton: false,\n      nav: true,\n      navPosition: 'top',\n      navContainer: false,\n      navAsThumbnails: false,\n      arrowKeys: false,\n      speed: 300,\n      autoplay: false,\n      autoplayPosition: 'top',\n      autoplayTimeout: 5000,\n      autoplayDirection: 'forward',\n      autoplayText: ['start', 'stop'],\n      autoplayHoverPause: false,\n      autoplayButton: false,\n      autoplayButtonOutput: true,\n      autoplayResetOnVisibility: true,\n      animateIn: 'tns-fadeIn',\n      animateOut: 'tns-fadeOut',\n      animateNormal: 'tns-normal',\n      animateDelay: false,\n      loop: true,\n      rewind: false,\n      autoHeight: false,\n      responsive: false,\n      lazyload: false,\n      lazyloadSelector: '.tns-lazy-img',\n      touch: true,\n      mouseDrag: false,\n      swipeAngle: 15,\n      nested: false,\n      preventActionWhenRunning: false,\n      preventScrollOnTouch: false,\n      freezable: true,\n      onInit: false,\n      useLocalStorage: true,\n      nonce: false\n    }, options || {});\n    var doc = document,\n        win = window,\n        KEYS = {\n      ENTER: 13,\n      SPACE: 32,\n      LEFT: 37,\n      RIGHT: 39\n    },\n        tnsStorage = {},\n        localStorageAccess = options.useLocalStorage;\n\n    if (localStorageAccess) {\n      // check browser version and local storage access\n      var browserInfo = navigator.userAgent;\n      var uid = new Date();\n\n      try {\n        tnsStorage = win.localStorage;\n\n        if (tnsStorage) {\n          tnsStorage.setItem(uid, uid);\n          localStorageAccess = tnsStorage.getItem(uid) == uid;\n          tnsStorage.removeItem(uid);\n        } else {\n          localStorageAccess = false;\n        }\n\n        if (!localStorageAccess) {\n          tnsStorage = {};\n        }\n      } catch (e) {\n        localStorageAccess = false;\n      }\n\n      if (localStorageAccess) {\n        // remove storage when browser version changes\n        if (tnsStorage['tnsApp'] && tnsStorage['tnsApp'] !== browserInfo) {\n          ['tC', 'tPL', 'tMQ', 'tTf', 't3D', 'tTDu', 'tTDe', 'tADu', 'tADe', 'tTE', 'tAE'].forEach(function (item) {\n            tnsStorage.removeItem(item);\n          });\n        } // update browserInfo\n\n\n        localStorage['tnsApp'] = browserInfo;\n      }\n    }\n\n    var CALC = tnsStorage['tC'] ? checkStorageValue(tnsStorage['tC']) : setLocalStorage(tnsStorage, 'tC', calc(), localStorageAccess),\n        PERCENTAGELAYOUT = tnsStorage['tPL'] ? checkStorageValue(tnsStorage['tPL']) : setLocalStorage(tnsStorage, 'tPL', percentageLayout(), localStorageAccess),\n        CSSMQ = tnsStorage['tMQ'] ? checkStorageValue(tnsStorage['tMQ']) : setLocalStorage(tnsStorage, 'tMQ', mediaquerySupport(), localStorageAccess),\n        TRANSFORM = tnsStorage['tTf'] ? checkStorageValue(tnsStorage['tTf']) : setLocalStorage(tnsStorage, 'tTf', whichProperty('transform'), localStorageAccess),\n        HAS3DTRANSFORMS = tnsStorage['t3D'] ? checkStorageValue(tnsStorage['t3D']) : setLocalStorage(tnsStorage, 't3D', has3DTransforms(TRANSFORM), localStorageAccess),\n        TRANSITIONDURATION = tnsStorage['tTDu'] ? checkStorageValue(tnsStorage['tTDu']) : setLocalStorage(tnsStorage, 'tTDu', whichProperty('transitionDuration'), localStorageAccess),\n        TRANSITIONDELAY = tnsStorage['tTDe'] ? checkStorageValue(tnsStorage['tTDe']) : setLocalStorage(tnsStorage, 'tTDe', whichProperty('transitionDelay'), localStorageAccess),\n        ANIMATIONDURATION = tnsStorage['tADu'] ? checkStorageValue(tnsStorage['tADu']) : setLocalStorage(tnsStorage, 'tADu', whichProperty('animationDuration'), localStorageAccess),\n        ANIMATIONDELAY = tnsStorage['tADe'] ? checkStorageValue(tnsStorage['tADe']) : setLocalStorage(tnsStorage, 'tADe', whichProperty('animationDelay'), localStorageAccess),\n        TRANSITIONEND = tnsStorage['tTE'] ? checkStorageValue(tnsStorage['tTE']) : setLocalStorage(tnsStorage, 'tTE', getEndProperty(TRANSITIONDURATION, 'Transition'), localStorageAccess),\n        ANIMATIONEND = tnsStorage['tAE'] ? checkStorageValue(tnsStorage['tAE']) : setLocalStorage(tnsStorage, 'tAE', getEndProperty(ANIMATIONDURATION, 'Animation'), localStorageAccess); // get element nodes from selectors\n\n    var supportConsoleWarn = win.console && typeof win.console.warn === \"function\",\n        tnsList = ['container', 'controlsContainer', 'prevButton', 'nextButton', 'navContainer', 'autoplayButton'],\n        optionsElements = {};\n    tnsList.forEach(function (item) {\n      if (typeof options[item] === 'string') {\n        var str = options[item],\n            el = doc.querySelector(str);\n        optionsElements[item] = str;\n\n        if (el && el.nodeName) {\n          options[item] = el;\n        } else {\n          if (supportConsoleWarn) {\n            console.warn('Can\\'t find', options[item]);\n          }\n\n          return;\n        }\n      }\n    }); // make sure at least 1 slide\n\n    if (options.container.children.length < 1) {\n      if (supportConsoleWarn) {\n        console.warn('No slides found in', options.container);\n      }\n\n      return;\n    } // update options\n\n\n    var responsive = options.responsive,\n        nested = options.nested,\n        carousel = options.mode === 'carousel' ? true : false;\n\n    if (responsive) {\n      // apply responsive[0] to options and remove it\n      if (0 in responsive) {\n        options = extend(options, responsive[0]);\n        delete responsive[0];\n      }\n\n      var responsiveTem = {};\n\n      for (var key in responsive) {\n        var val = responsive[key]; // update responsive\n        // from: 300: 2\n        // to:\n        //   300: {\n        //     items: 2\n        //   }\n\n        val = typeof val === 'number' ? {\n          items: val\n        } : val;\n        responsiveTem[key] = val;\n      }\n\n      responsive = responsiveTem;\n      responsiveTem = null;\n    } // update options\n\n\n    function updateOptions(obj) {\n      for (var key in obj) {\n        if (!carousel) {\n          if (key === 'slideBy') {\n            obj[key] = 'page';\n          }\n\n          if (key === 'edgePadding') {\n            obj[key] = false;\n          }\n\n          if (key === 'autoHeight') {\n            obj[key] = false;\n          }\n        } // update responsive options\n\n\n        if (key === 'responsive') {\n          updateOptions(obj[key]);\n        }\n      }\n    }\n\n    if (!carousel) {\n      updateOptions(options);\n    } // === define and set variables ===\n\n\n    if (!carousel) {\n      options.axis = 'horizontal';\n      options.slideBy = 'page';\n      options.edgePadding = false;\n      var animateIn = options.animateIn,\n          animateOut = options.animateOut,\n          animateDelay = options.animateDelay,\n          animateNormal = options.animateNormal;\n    }\n\n    var horizontal = options.axis === 'horizontal' ? true : false,\n        outerWrapper = doc.createElement('div'),\n        innerWrapper = doc.createElement('div'),\n        middleWrapper,\n        container = options.container,\n        containerParent = container.parentNode,\n        containerHTML = container.outerHTML,\n        slideItems = container.children,\n        slideCount = slideItems.length,\n        breakpointZone,\n        windowWidth = getWindowWidth(),\n        isOn = false;\n\n    if (responsive) {\n      setBreakpointZone();\n    }\n\n    if (carousel) {\n      container.className += ' tns-vpfix';\n    } // fixedWidth: viewport > rightBoundary > indexMax\n\n\n    var autoWidth = options.autoWidth,\n        fixedWidth = getOption('fixedWidth'),\n        edgePadding = getOption('edgePadding'),\n        gutter = getOption('gutter'),\n        viewport = getViewportWidth(),\n        center = getOption('center'),\n        items = !autoWidth ? Math.floor(getOption('items')) : 1,\n        slideBy = getOption('slideBy'),\n        viewportMax = options.viewportMax || options.fixedWidthViewportWidth,\n        arrowKeys = getOption('arrowKeys'),\n        speed = getOption('speed'),\n        rewind = options.rewind,\n        loop = rewind ? false : options.loop,\n        autoHeight = getOption('autoHeight'),\n        controls = getOption('controls'),\n        controlsText = getOption('controlsText'),\n        nav = getOption('nav'),\n        touch = getOption('touch'),\n        mouseDrag = getOption('mouseDrag'),\n        autoplay = getOption('autoplay'),\n        autoplayTimeout = getOption('autoplayTimeout'),\n        autoplayText = getOption('autoplayText'),\n        autoplayHoverPause = getOption('autoplayHoverPause'),\n        autoplayResetOnVisibility = getOption('autoplayResetOnVisibility'),\n        sheet = createStyleSheet(null, getOption('nonce')),\n        lazyload = options.lazyload,\n        lazyloadSelector = options.lazyloadSelector,\n        slidePositions,\n        // collection of slide positions\n    slideItemsOut = [],\n        cloneCount = loop ? getCloneCountForLoop() : 0,\n        slideCountNew = !carousel ? slideCount + cloneCount : slideCount + cloneCount * 2,\n        hasRightDeadZone = (fixedWidth || autoWidth) && !loop ? true : false,\n        rightBoundary = fixedWidth ? getRightBoundary() : null,\n        updateIndexBeforeTransform = !carousel || !loop ? true : false,\n        // transform\n    transformAttr = horizontal ? 'left' : 'top',\n        transformPrefix = '',\n        transformPostfix = '',\n        // index\n    getIndexMax = function () {\n      if (fixedWidth) {\n        return function () {\n          return center && !loop ? slideCount - 1 : Math.ceil(-rightBoundary / (fixedWidth + gutter));\n        };\n      } else if (autoWidth) {\n        return function () {\n          for (var i = 0; i < slideCountNew; i++) {\n            if (slidePositions[i] >= -rightBoundary) {\n              return i;\n            }\n          }\n        };\n      } else {\n        return function () {\n          if (center && carousel && !loop) {\n            return slideCount - 1;\n          } else {\n            return loop || carousel ? Math.max(0, slideCountNew - Math.ceil(items)) : slideCountNew - 1;\n          }\n        };\n      }\n    }(),\n        index = getStartIndex(getOption('startIndex')),\n        indexCached = index,\n        displayIndex = getCurrentSlide(),\n        indexMin = 0,\n        indexMax = !autoWidth ? getIndexMax() : null,\n        // resize\n    resizeTimer,\n        preventActionWhenRunning = options.preventActionWhenRunning,\n        swipeAngle = options.swipeAngle,\n        moveDirectionExpected = swipeAngle ? '?' : true,\n        running = false,\n        onInit = options.onInit,\n        events = new Events(),\n        // id, class\n    newContainerClasses = ' tns-slider tns-' + options.mode,\n        slideId = container.id || getSlideId(),\n        disable = getOption('disable'),\n        disabled = false,\n        freezable = options.freezable,\n        freeze = freezable && !autoWidth ? getFreeze() : false,\n        frozen = false,\n        controlsEvents = {\n      'click': onControlsClick,\n      'keydown': onControlsKeydown\n    },\n        navEvents = {\n      'click': onNavClick,\n      'keydown': onNavKeydown\n    },\n        hoverEvents = {\n      'mouseover': mouseoverPause,\n      'mouseout': mouseoutRestart\n    },\n        visibilityEvent = {\n      'visibilitychange': onVisibilityChange\n    },\n        docmentKeydownEvent = {\n      'keydown': onDocumentKeydown\n    },\n        touchEvents = {\n      'touchstart': onPanStart,\n      'touchmove': onPanMove,\n      'touchend': onPanEnd,\n      'touchcancel': onPanEnd\n    },\n        dragEvents = {\n      'mousedown': onPanStart,\n      'mousemove': onPanMove,\n      'mouseup': onPanEnd,\n      'mouseleave': onPanEnd\n    },\n        hasControls = hasOption('controls'),\n        hasNav = hasOption('nav'),\n        navAsThumbnails = autoWidth ? true : options.navAsThumbnails,\n        hasAutoplay = hasOption('autoplay'),\n        hasTouch = hasOption('touch'),\n        hasMouseDrag = hasOption('mouseDrag'),\n        slideActiveClass = 'tns-slide-active',\n        slideClonedClass = 'tns-slide-cloned',\n        imgCompleteClass = 'tns-complete',\n        imgEvents = {\n      'load': onImgLoaded,\n      'error': onImgFailed\n    },\n        imgsComplete,\n        liveregionCurrent,\n        preventScroll = options.preventScrollOnTouch === 'force' ? true : false; // controls\n\n\n    if (hasControls) {\n      var controlsContainer = options.controlsContainer,\n          controlsContainerHTML = options.controlsContainer ? options.controlsContainer.outerHTML : '',\n          prevButton = options.prevButton,\n          nextButton = options.nextButton,\n          prevButtonHTML = options.prevButton ? options.prevButton.outerHTML : '',\n          nextButtonHTML = options.nextButton ? options.nextButton.outerHTML : '',\n          prevIsButton,\n          nextIsButton;\n    } // nav\n\n\n    if (hasNav) {\n      var navContainer = options.navContainer,\n          navContainerHTML = options.navContainer ? options.navContainer.outerHTML : '',\n          navItems,\n          pages = autoWidth ? slideCount : getPages(),\n          pagesCached = 0,\n          navClicked = -1,\n          navCurrentIndex = getCurrentNavIndex(),\n          navCurrentIndexCached = navCurrentIndex,\n          navActiveClass = 'tns-nav-active',\n          navStr = 'Carousel Page ',\n          navStrCurrent = ' (Current Slide)';\n    } // autoplay\n\n\n    if (hasAutoplay) {\n      var autoplayDirection = options.autoplayDirection === 'forward' ? 1 : -1,\n          autoplayButton = options.autoplayButton,\n          autoplayButtonHTML = options.autoplayButton ? options.autoplayButton.outerHTML : '',\n          autoplayHtmlStrings = ['<span class=\\'tns-visually-hidden\\'>', ' animation</span>'],\n          autoplayTimer,\n          animating,\n          autoplayHoverPaused,\n          autoplayUserPaused,\n          autoplayVisibilityPaused;\n    }\n\n    if (hasTouch || hasMouseDrag) {\n      var initPosition = {},\n          lastPosition = {},\n          translateInit,\n          disX,\n          disY,\n          panStart = false,\n          rafIndex,\n          getDist = horizontal ? function (a, b) {\n        return a.x - b.x;\n      } : function (a, b) {\n        return a.y - b.y;\n      };\n    } // disable slider when slidecount <= items\n\n\n    if (!autoWidth) {\n      resetVariblesWhenDisable(disable || freeze);\n    }\n\n    if (TRANSFORM) {\n      transformAttr = TRANSFORM;\n      transformPrefix = 'translate';\n\n      if (HAS3DTRANSFORMS) {\n        transformPrefix += horizontal ? '3d(' : '3d(0px, ';\n        transformPostfix = horizontal ? ', 0px, 0px)' : ', 0px)';\n      } else {\n        transformPrefix += horizontal ? 'X(' : 'Y(';\n        transformPostfix = ')';\n      }\n    }\n\n    if (carousel) {\n      container.className = container.className.replace('tns-vpfix', '');\n    }\n\n    initStructure();\n    initSheet();\n    initSliderTransform(); // === COMMON FUNCTIONS === //\n\n    function resetVariblesWhenDisable(condition) {\n      if (condition) {\n        controls = nav = touch = mouseDrag = arrowKeys = autoplay = autoplayHoverPause = autoplayResetOnVisibility = false;\n      }\n    }\n\n    function getCurrentSlide() {\n      var tem = carousel ? index - cloneCount : index;\n\n      while (tem < 0) {\n        tem += slideCount;\n      }\n\n      return tem % slideCount + 1;\n    }\n\n    function getStartIndex(ind) {\n      ind = ind ? Math.max(0, Math.min(loop ? slideCount - 1 : slideCount - items, ind)) : 0;\n      return carousel ? ind + cloneCount : ind;\n    }\n\n    function getAbsIndex(i) {\n      if (i == null) {\n        i = index;\n      }\n\n      if (carousel) {\n        i -= cloneCount;\n      }\n\n      while (i < 0) {\n        i += slideCount;\n      }\n\n      return Math.floor(i % slideCount);\n    }\n\n    function getCurrentNavIndex() {\n      var absIndex = getAbsIndex(),\n          result;\n      result = navAsThumbnails ? absIndex : fixedWidth || autoWidth ? Math.ceil((absIndex + 1) * pages / slideCount - 1) : Math.floor(absIndex / items); // set active nav to the last one when reaches the right edge\n\n      if (!loop && carousel && index === indexMax) {\n        result = pages - 1;\n      }\n\n      return result;\n    }\n\n    function getItemsMax() {\n      // fixedWidth or autoWidth while viewportMax is not available\n      if (autoWidth || fixedWidth && !viewportMax) {\n        return slideCount - 1; // most cases\n      } else {\n        var str = fixedWidth ? 'fixedWidth' : 'items',\n            arr = [];\n\n        if (fixedWidth || options[str] < slideCount) {\n          arr.push(options[str]);\n        }\n\n        if (responsive) {\n          for (var bp in responsive) {\n            var tem = responsive[bp][str];\n\n            if (tem && (fixedWidth || tem < slideCount)) {\n              arr.push(tem);\n            }\n          }\n        }\n\n        if (!arr.length) {\n          arr.push(0);\n        }\n\n        return Math.ceil(fixedWidth ? viewportMax / Math.min.apply(null, arr) : Math.max.apply(null, arr));\n      }\n    }\n\n    function getCloneCountForLoop() {\n      var itemsMax = getItemsMax(),\n          result = carousel ? Math.ceil((itemsMax * 5 - slideCount) / 2) : itemsMax * 4 - slideCount;\n      result = Math.max(itemsMax, result);\n      return hasOption('edgePadding') ? result + 1 : result;\n    }\n\n    function getWindowWidth() {\n      return win.innerWidth || doc.documentElement.clientWidth || doc.body.clientWidth;\n    }\n\n    function getInsertPosition(pos) {\n      return pos === 'top' ? 'afterbegin' : 'beforeend';\n    }\n\n    function getClientWidth(el) {\n      if (el == null) {\n        return;\n      }\n\n      var div = doc.createElement('div'),\n          rect,\n          width;\n      el.appendChild(div);\n      rect = div.getBoundingClientRect();\n      width = rect.right - rect.left;\n      div.remove();\n      return width || getClientWidth(el.parentNode);\n    }\n\n    function getViewportWidth() {\n      var gap = edgePadding ? edgePadding * 2 - gutter : 0;\n      return getClientWidth(containerParent) - gap;\n    }\n\n    function hasOption(item) {\n      if (options[item]) {\n        return true;\n      } else {\n        if (responsive) {\n          for (var bp in responsive) {\n            if (responsive[bp][item]) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      }\n    } // get option:\n    // fixed width: viewport, fixedWidth, gutter => items\n    // others: window width => all variables\n    // all: items => slideBy\n\n\n    function getOption(item, ww) {\n      if (ww == null) {\n        ww = windowWidth;\n      }\n\n      if (item === 'items' && fixedWidth) {\n        return Math.floor((viewport + gutter) / (fixedWidth + gutter)) || 1;\n      } else {\n        var result = options[item];\n\n        if (responsive) {\n          for (var bp in responsive) {\n            // bp: convert string to number\n            if (ww >= parseInt(bp)) {\n              if (item in responsive[bp]) {\n                result = responsive[bp][item];\n              }\n            }\n          }\n        }\n\n        if (item === 'slideBy' && result === 'page') {\n          result = getOption('items');\n        }\n\n        if (!carousel && (item === 'slideBy' || item === 'items')) {\n          result = Math.floor(result);\n        }\n\n        return result;\n      }\n    }\n\n    function getSlideMarginLeft(i) {\n      return CALC ? CALC + '(' + i * 100 + '% / ' + slideCountNew + ')' : i * 100 / slideCountNew + '%';\n    }\n\n    function getInnerWrapperStyles(edgePaddingTem, gutterTem, fixedWidthTem, speedTem, autoHeightBP) {\n      var str = '';\n\n      if (edgePaddingTem !== undefined) {\n        var gap = edgePaddingTem;\n\n        if (gutterTem) {\n          gap -= gutterTem;\n        }\n\n        str = horizontal ? 'margin: 0 ' + gap + 'px 0 ' + edgePaddingTem + 'px;' : 'margin: ' + edgePaddingTem + 'px 0 ' + gap + 'px 0;';\n      } else if (gutterTem && !fixedWidthTem) {\n        var gutterTemUnit = '-' + gutterTem + 'px',\n            dir = horizontal ? gutterTemUnit + ' 0 0' : '0 ' + gutterTemUnit + ' 0';\n        str = 'margin: 0 ' + dir + ';';\n      }\n\n      if (!carousel && autoHeightBP && TRANSITIONDURATION && speedTem) {\n        str += getTransitionDurationStyle(speedTem);\n      }\n\n      return str;\n    }\n\n    function getContainerWidth(fixedWidthTem, gutterTem, itemsTem) {\n      if (fixedWidthTem) {\n        return (fixedWidthTem + gutterTem) * slideCountNew + 'px';\n      } else {\n        return CALC ? CALC + '(' + slideCountNew * 100 + '% / ' + itemsTem + ')' : slideCountNew * 100 / itemsTem + '%';\n      }\n    }\n\n    function getSlideWidthStyle(fixedWidthTem, gutterTem, itemsTem) {\n      var width;\n\n      if (fixedWidthTem) {\n        width = fixedWidthTem + gutterTem + 'px';\n      } else {\n        if (!carousel) {\n          itemsTem = Math.floor(itemsTem);\n        }\n\n        var dividend = carousel ? slideCountNew : itemsTem;\n        width = CALC ? CALC + '(100% / ' + dividend + ')' : 100 / dividend + '%';\n      }\n\n      width = 'width:' + width; // inner slider: overwrite outer slider styles\n\n      return nested !== 'inner' ? width + ';' : width + ' !important;';\n    }\n\n    function getSlideGutterStyle(gutterTem) {\n      var str = ''; // gutter maybe interger || 0\n      // so can't use 'if (gutter)'\n\n      if (gutterTem !== false) {\n        var prop = horizontal ? 'padding-' : 'margin-',\n            dir = horizontal ? 'right' : 'bottom';\n        str = prop + dir + ': ' + gutterTem + 'px;';\n      }\n\n      return str;\n    }\n\n    function getCSSPrefix(name, num) {\n      var prefix = name.substring(0, name.length - num).toLowerCase();\n\n      if (prefix) {\n        prefix = '-' + prefix + '-';\n      }\n\n      return prefix;\n    }\n\n    function getTransitionDurationStyle(speed) {\n      return getCSSPrefix(TRANSITIONDURATION, 18) + 'transition-duration:' + speed / 1000 + 's;';\n    }\n\n    function getAnimationDurationStyle(speed) {\n      return getCSSPrefix(ANIMATIONDURATION, 17) + 'animation-duration:' + speed / 1000 + 's;';\n    }\n\n    function initStructure() {\n      var classOuter = 'tns-outer',\n          classInner = 'tns-inner',\n          hasGutter = hasOption('gutter');\n      outerWrapper.className = classOuter;\n      innerWrapper.className = classInner;\n      outerWrapper.id = slideId + '-ow';\n      innerWrapper.id = slideId + '-iw'; // set container properties\n\n      if (container.id === '') {\n        container.id = slideId;\n      }\n\n      newContainerClasses += PERCENTAGELAYOUT || autoWidth ? ' tns-subpixel' : ' tns-no-subpixel';\n      newContainerClasses += CALC ? ' tns-calc' : ' tns-no-calc';\n\n      if (autoWidth) {\n        newContainerClasses += ' tns-autowidth';\n      }\n\n      newContainerClasses += ' tns-' + options.axis;\n      container.className += newContainerClasses; // add constrain layer for carousel\n\n      if (carousel) {\n        middleWrapper = doc.createElement('div');\n        middleWrapper.id = slideId + '-mw';\n        middleWrapper.className = 'tns-ovh';\n        outerWrapper.appendChild(middleWrapper);\n        middleWrapper.appendChild(innerWrapper);\n      } else {\n        outerWrapper.appendChild(innerWrapper);\n      }\n\n      if (autoHeight) {\n        var wp = middleWrapper ? middleWrapper : innerWrapper;\n        wp.className += ' tns-ah';\n      }\n\n      containerParent.insertBefore(outerWrapper, container);\n      innerWrapper.appendChild(container); // add id, class, aria attributes\n      // before clone slides\n\n      forEach(slideItems, function (item, i) {\n        addClass(item, 'tns-item');\n\n        if (!item.id) {\n          item.id = slideId + '-item' + i;\n        }\n\n        if (!carousel && animateNormal) {\n          addClass(item, animateNormal);\n        }\n\n        setAttrs(item, {\n          'aria-hidden': 'true',\n          'tabindex': '-1'\n        });\n      }); // ## clone slides\n      // carousel: n + slides + n\n      // gallery:      slides + n\n\n      if (cloneCount) {\n        var fragmentBefore = doc.createDocumentFragment(),\n            fragmentAfter = doc.createDocumentFragment();\n\n        for (var j = cloneCount; j--;) {\n          var num = j % slideCount,\n              cloneFirst = slideItems[num].cloneNode(true);\n          addClass(cloneFirst, slideClonedClass);\n          removeAttrs(cloneFirst, 'id');\n          fragmentAfter.insertBefore(cloneFirst, fragmentAfter.firstChild);\n\n          if (carousel) {\n            var cloneLast = slideItems[slideCount - 1 - num].cloneNode(true);\n            addClass(cloneLast, slideClonedClass);\n            removeAttrs(cloneLast, 'id');\n            fragmentBefore.appendChild(cloneLast);\n          }\n        }\n\n        container.insertBefore(fragmentBefore, container.firstChild);\n        container.appendChild(fragmentAfter);\n        slideItems = container.children;\n      }\n    }\n\n    function initSliderTransform() {\n      // ## images loaded/failed\n      if (hasOption('autoHeight') || autoWidth || !horizontal) {\n        var imgs = container.querySelectorAll('img'); // add img load event listener\n\n        forEach(imgs, function (img) {\n          var src = img.src;\n\n          if (!lazyload) {\n            // not data img\n            if (src && src.indexOf('data:image') < 0) {\n              img.src = '';\n              addEvents(img, imgEvents);\n              addClass(img, 'loading');\n              img.src = src; // data img\n            } else {\n              imgLoaded(img);\n            }\n          }\n        }); // set imgsComplete\n\n        raf(function () {\n          imgsLoadedCheck(arrayFromNodeList(imgs), function () {\n            imgsComplete = true;\n          });\n        }); // reset imgs for auto height: check visible imgs only\n\n        if (hasOption('autoHeight')) {\n          imgs = getImageArray(index, Math.min(index + items - 1, slideCountNew - 1));\n        }\n\n        lazyload ? initSliderTransformStyleCheck() : raf(function () {\n          imgsLoadedCheck(arrayFromNodeList(imgs), initSliderTransformStyleCheck);\n        });\n      } else {\n        // set container transform property\n        if (carousel) {\n          doContainerTransformSilent();\n        } // update slider tools and events\n\n\n        initTools();\n        initEvents();\n      }\n    }\n\n    function initSliderTransformStyleCheck() {\n      if (autoWidth && slideCount > 1) {\n        // check styles application\n        var num = loop ? index : slideCount - 1;\n\n        (function stylesApplicationCheck() {\n          var left = slideItems[num].getBoundingClientRect().left;\n          var right = slideItems[num - 1].getBoundingClientRect().right;\n          Math.abs(left - right) <= 1 ? initSliderTransformCore() : setTimeout(function () {\n            stylesApplicationCheck();\n          }, 16);\n        })();\n      } else {\n        initSliderTransformCore();\n      }\n    }\n\n    function initSliderTransformCore() {\n      // run Fn()s which are rely on image loading\n      if (!horizontal || autoWidth) {\n        setSlidePositions();\n\n        if (autoWidth) {\n          rightBoundary = getRightBoundary();\n\n          if (freezable) {\n            freeze = getFreeze();\n          }\n\n          indexMax = getIndexMax(); // <= slidePositions, rightBoundary <=\n\n          resetVariblesWhenDisable(disable || freeze);\n        } else {\n          updateContentWrapperHeight();\n        }\n      } // set container transform property\n\n\n      if (carousel) {\n        doContainerTransformSilent();\n      } // update slider tools and events\n\n\n      initTools();\n      initEvents();\n    }\n\n    function initSheet() {\n      // gallery:\n      // set animation classes and left value for gallery slider\n      if (!carousel) {\n        for (var i = index, l = index + Math.min(slideCount, items); i < l; i++) {\n          var item = slideItems[i];\n          item.style.left = (i - index) * 100 / items + '%';\n          addClass(item, animateIn);\n          removeClass(item, animateNormal);\n        }\n      } // #### LAYOUT\n      // ## INLINE-BLOCK VS FLOAT\n      // ## PercentageLayout:\n      // slides: inline-block\n      // remove blank space between slides by set font-size: 0\n      // ## Non PercentageLayout:\n      // slides: float\n      //         margin-right: -100%\n      //         margin-left: ~\n      // Resource: https://docs.google.com/spreadsheets/d/147up245wwTXeQYve3BRSAD4oVcvQmuGsFteJOeA5xNQ/edit?usp=sharing\n\n\n      if (horizontal) {\n        if (PERCENTAGELAYOUT || autoWidth) {\n          addCSSRule(sheet, '#' + slideId + ' > .tns-item', 'font-size:' + win.getComputedStyle(slideItems[0]).fontSize + ';', getCssRulesLength(sheet));\n          addCSSRule(sheet, '#' + slideId, 'font-size:0;', getCssRulesLength(sheet));\n        } else if (carousel) {\n          forEach(slideItems, function (slide, i) {\n            slide.style.marginLeft = getSlideMarginLeft(i);\n          });\n        }\n      } // ## BASIC STYLES\n\n\n      if (CSSMQ) {\n        // middle wrapper style\n        if (TRANSITIONDURATION) {\n          var str = middleWrapper && options.autoHeight ? getTransitionDurationStyle(options.speed) : '';\n          addCSSRule(sheet, '#' + slideId + '-mw', str, getCssRulesLength(sheet));\n        } // inner wrapper styles\n\n\n        str = getInnerWrapperStyles(options.edgePadding, options.gutter, options.fixedWidth, options.speed, options.autoHeight);\n        addCSSRule(sheet, '#' + slideId + '-iw', str, getCssRulesLength(sheet)); // container styles\n\n        if (carousel) {\n          str = horizontal && !autoWidth ? 'width:' + getContainerWidth(options.fixedWidth, options.gutter, options.items) + ';' : '';\n\n          if (TRANSITIONDURATION) {\n            str += getTransitionDurationStyle(speed);\n          }\n\n          addCSSRule(sheet, '#' + slideId, str, getCssRulesLength(sheet));\n        } // slide styles\n\n\n        str = horizontal && !autoWidth ? getSlideWidthStyle(options.fixedWidth, options.gutter, options.items) : '';\n\n        if (options.gutter) {\n          str += getSlideGutterStyle(options.gutter);\n        } // set gallery items transition-duration\n\n\n        if (!carousel) {\n          if (TRANSITIONDURATION) {\n            str += getTransitionDurationStyle(speed);\n          }\n\n          if (ANIMATIONDURATION) {\n            str += getAnimationDurationStyle(speed);\n          }\n        }\n\n        if (str) {\n          addCSSRule(sheet, '#' + slideId + ' > .tns-item', str, getCssRulesLength(sheet));\n        } // non CSS mediaqueries: IE8\n        // ## update inner wrapper, container, slides if needed\n        // set inline styles for inner wrapper & container\n        // insert stylesheet (one line) for slides only (since slides are many)\n\n      } else {\n        // middle wrapper styles\n        update_carousel_transition_duration(); // inner wrapper styles\n\n        innerWrapper.style.cssText = getInnerWrapperStyles(edgePadding, gutter, fixedWidth, autoHeight); // container styles\n\n        if (carousel && horizontal && !autoWidth) {\n          container.style.width = getContainerWidth(fixedWidth, gutter, items);\n        } // slide styles\n\n\n        var str = horizontal && !autoWidth ? getSlideWidthStyle(fixedWidth, gutter, items) : '';\n\n        if (gutter) {\n          str += getSlideGutterStyle(gutter);\n        } // append to the last line\n\n\n        if (str) {\n          addCSSRule(sheet, '#' + slideId + ' > .tns-item', str, getCssRulesLength(sheet));\n        }\n      } // ## MEDIAQUERIES\n\n\n      if (responsive && CSSMQ) {\n        for (var bp in responsive) {\n          // bp: convert string to number\n          bp = parseInt(bp);\n          var opts = responsive[bp],\n              str = '',\n              middleWrapperStr = '',\n              innerWrapperStr = '',\n              containerStr = '',\n              slideStr = '',\n              itemsBP = !autoWidth ? getOption('items', bp) : null,\n              fixedWidthBP = getOption('fixedWidth', bp),\n              speedBP = getOption('speed', bp),\n              edgePaddingBP = getOption('edgePadding', bp),\n              autoHeightBP = getOption('autoHeight', bp),\n              gutterBP = getOption('gutter', bp); // middle wrapper string\n\n          if (TRANSITIONDURATION && middleWrapper && getOption('autoHeight', bp) && 'speed' in opts) {\n            middleWrapperStr = '#' + slideId + '-mw{' + getTransitionDurationStyle(speedBP) + '}';\n          } // inner wrapper string\n\n\n          if ('edgePadding' in opts || 'gutter' in opts) {\n            innerWrapperStr = '#' + slideId + '-iw{' + getInnerWrapperStyles(edgePaddingBP, gutterBP, fixedWidthBP, speedBP, autoHeightBP) + '}';\n          } // container string\n\n\n          if (carousel && horizontal && !autoWidth && ('fixedWidth' in opts || 'items' in opts || fixedWidth && 'gutter' in opts)) {\n            containerStr = 'width:' + getContainerWidth(fixedWidthBP, gutterBP, itemsBP) + ';';\n          }\n\n          if (TRANSITIONDURATION && 'speed' in opts) {\n            containerStr += getTransitionDurationStyle(speedBP);\n          }\n\n          if (containerStr) {\n            containerStr = '#' + slideId + '{' + containerStr + '}';\n          } // slide string\n\n\n          if ('fixedWidth' in opts || fixedWidth && 'gutter' in opts || !carousel && 'items' in opts) {\n            slideStr += getSlideWidthStyle(fixedWidthBP, gutterBP, itemsBP);\n          }\n\n          if ('gutter' in opts) {\n            slideStr += getSlideGutterStyle(gutterBP);\n          } // set gallery items transition-duration\n\n\n          if (!carousel && 'speed' in opts) {\n            if (TRANSITIONDURATION) {\n              slideStr += getTransitionDurationStyle(speedBP);\n            }\n\n            if (ANIMATIONDURATION) {\n              slideStr += getAnimationDurationStyle(speedBP);\n            }\n          }\n\n          if (slideStr) {\n            slideStr = '#' + slideId + ' > .tns-item{' + slideStr + '}';\n          } // add up\n\n\n          str = middleWrapperStr + innerWrapperStr + containerStr + slideStr;\n\n          if (str) {\n            sheet.insertRule('@media (min-width: ' + bp / 16 + 'em) {' + str + '}', sheet.cssRules.length);\n          }\n        }\n      }\n    }\n\n    function initTools() {\n      // == slides ==\n      updateSlideStatus(); // == live region ==\n\n      outerWrapper.insertAdjacentHTML('afterbegin', '<div class=\"tns-liveregion tns-visually-hidden\" aria-live=\"polite\" aria-atomic=\"true\">slide <span class=\"current\">' + getLiveRegionStr() + '</span>  of ' + slideCount + '</div>');\n      liveregionCurrent = outerWrapper.querySelector('.tns-liveregion .current'); // == autoplayInit ==\n\n      if (hasAutoplay) {\n        var txt = autoplay ? 'stop' : 'start';\n\n        if (autoplayButton) {\n          setAttrs(autoplayButton, {\n            'data-action': txt\n          });\n        } else if (options.autoplayButtonOutput) {\n          outerWrapper.insertAdjacentHTML(getInsertPosition(options.autoplayPosition), '<button type=\"button\" data-action=\"' + txt + '\">' + autoplayHtmlStrings[0] + txt + autoplayHtmlStrings[1] + autoplayText[0] + '</button>');\n          autoplayButton = outerWrapper.querySelector('[data-action]');\n        } // add event\n\n\n        if (autoplayButton) {\n          addEvents(autoplayButton, {\n            'click': toggleAutoplay\n          });\n        }\n\n        if (autoplay) {\n          startAutoplay();\n\n          if (autoplayHoverPause) {\n            addEvents(container, hoverEvents);\n          }\n\n          if (autoplayResetOnVisibility) {\n            addEvents(container, visibilityEvent);\n          }\n        }\n      } // == navInit ==\n\n\n      if (hasNav) {\n        var initIndex = !carousel ? 0 : cloneCount; // customized nav\n        // will not hide the navs in case they're thumbnails\n\n        if (navContainer) {\n          setAttrs(navContainer, {\n            'aria-label': 'Carousel Pagination'\n          });\n          navItems = navContainer.children;\n          forEach(navItems, function (item, i) {\n            setAttrs(item, {\n              'data-nav': i,\n              'tabindex': '-1',\n              'aria-label': navStr + (i + 1),\n              'aria-controls': slideId\n            });\n          }); // generated nav\n        } else {\n          var navHtml = '',\n              hiddenStr = navAsThumbnails ? '' : 'style=\"display:none\"';\n\n          for (var i = 0; i < slideCount; i++) {\n            // hide nav items by default\n            navHtml += '<button type=\"button\" data-nav=\"' + i + '\" tabindex=\"-1\" aria-controls=\"' + slideId + '\" ' + hiddenStr + ' aria-label=\"' + navStr + (i + 1) + '\"></button>';\n          }\n\n          navHtml = '<div class=\"tns-nav\" aria-label=\"Carousel Pagination\">' + navHtml + '</div>';\n          outerWrapper.insertAdjacentHTML(getInsertPosition(options.navPosition), navHtml);\n          navContainer = outerWrapper.querySelector('.tns-nav');\n          navItems = navContainer.children;\n        }\n\n        updateNavVisibility(); // add transition\n\n        if (TRANSITIONDURATION) {\n          var prefix = TRANSITIONDURATION.substring(0, TRANSITIONDURATION.length - 18).toLowerCase(),\n              str = 'transition: all ' + speed / 1000 + 's';\n\n          if (prefix) {\n            str = '-' + prefix + '-' + str;\n          }\n\n          addCSSRule(sheet, '[aria-controls^=' + slideId + '-item]', str, getCssRulesLength(sheet));\n        }\n\n        setAttrs(navItems[navCurrentIndex], {\n          'aria-label': navStr + (navCurrentIndex + 1) + navStrCurrent\n        });\n        removeAttrs(navItems[navCurrentIndex], 'tabindex');\n        addClass(navItems[navCurrentIndex], navActiveClass); // add events\n\n        addEvents(navContainer, navEvents);\n      } // == controlsInit ==\n\n\n      if (hasControls) {\n        if (!controlsContainer && (!prevButton || !nextButton)) {\n          outerWrapper.insertAdjacentHTML(getInsertPosition(options.controlsPosition), '<div class=\"tns-controls\" aria-label=\"Carousel Navigation\" tabindex=\"0\"><button type=\"button\" data-controls=\"prev\" tabindex=\"-1\" aria-controls=\"' + slideId + '\">' + controlsText[0] + '</button><button type=\"button\" data-controls=\"next\" tabindex=\"-1\" aria-controls=\"' + slideId + '\">' + controlsText[1] + '</button></div>');\n          controlsContainer = outerWrapper.querySelector('.tns-controls');\n        }\n\n        if (!prevButton || !nextButton) {\n          prevButton = controlsContainer.children[0];\n          nextButton = controlsContainer.children[1];\n        }\n\n        if (options.controlsContainer) {\n          setAttrs(controlsContainer, {\n            'aria-label': 'Carousel Navigation',\n            'tabindex': '0'\n          });\n        }\n\n        if (options.controlsContainer || options.prevButton && options.nextButton) {\n          setAttrs([prevButton, nextButton], {\n            'aria-controls': slideId,\n            'tabindex': '-1'\n          });\n        }\n\n        if (options.controlsContainer || options.prevButton && options.nextButton) {\n          setAttrs(prevButton, {\n            'data-controls': 'prev'\n          });\n          setAttrs(nextButton, {\n            'data-controls': 'next'\n          });\n        }\n\n        prevIsButton = isButton(prevButton);\n        nextIsButton = isButton(nextButton);\n        updateControlsStatus(); // add events\n\n        if (controlsContainer) {\n          addEvents(controlsContainer, controlsEvents);\n        } else {\n          addEvents(prevButton, controlsEvents);\n          addEvents(nextButton, controlsEvents);\n        }\n      } // hide tools if needed\n\n\n      disableUI();\n    }\n\n    function initEvents() {\n      // add events\n      if (carousel && TRANSITIONEND) {\n        var eve = {};\n        eve[TRANSITIONEND] = onTransitionEnd;\n        addEvents(container, eve);\n      }\n\n      if (touch) {\n        addEvents(container, touchEvents, options.preventScrollOnTouch);\n      }\n\n      if (mouseDrag) {\n        addEvents(container, dragEvents);\n      }\n\n      if (arrowKeys) {\n        addEvents(doc, docmentKeydownEvent);\n      }\n\n      if (nested === 'inner') {\n        events.on('outerResized', function () {\n          resizeTasks();\n          events.emit('innerLoaded', info());\n        });\n      } else if (responsive || fixedWidth || autoWidth || autoHeight || !horizontal) {\n        addEvents(win, {\n          'resize': onResize\n        });\n      }\n\n      if (autoHeight) {\n        if (nested === 'outer') {\n          events.on('innerLoaded', doAutoHeight);\n        } else if (!disable) {\n          doAutoHeight();\n        }\n      }\n\n      doLazyLoad();\n\n      if (disable) {\n        disableSlider();\n      } else if (freeze) {\n        freezeSlider();\n      }\n\n      events.on('indexChanged', additionalUpdates);\n\n      if (nested === 'inner') {\n        events.emit('innerLoaded', info());\n      }\n\n      if (typeof onInit === 'function') {\n        onInit(info());\n      }\n\n      isOn = true;\n    }\n\n    function destroy() {\n      // sheet\n      sheet.disabled = true;\n\n      if (sheet.ownerNode) {\n        sheet.ownerNode.remove();\n      } // remove win event listeners\n\n\n      removeEvents(win, {\n        'resize': onResize\n      }); // arrowKeys, controls, nav\n\n      if (arrowKeys) {\n        removeEvents(doc, docmentKeydownEvent);\n      }\n\n      if (controlsContainer) {\n        removeEvents(controlsContainer, controlsEvents);\n      }\n\n      if (navContainer) {\n        removeEvents(navContainer, navEvents);\n      } // autoplay\n\n\n      removeEvents(container, hoverEvents);\n      removeEvents(container, visibilityEvent);\n\n      if (autoplayButton) {\n        removeEvents(autoplayButton, {\n          'click': toggleAutoplay\n        });\n      }\n\n      if (autoplay) {\n        clearInterval(autoplayTimer);\n      } // container\n\n\n      if (carousel && TRANSITIONEND) {\n        var eve = {};\n        eve[TRANSITIONEND] = onTransitionEnd;\n        removeEvents(container, eve);\n      }\n\n      if (touch) {\n        removeEvents(container, touchEvents);\n      }\n\n      if (mouseDrag) {\n        removeEvents(container, dragEvents);\n      } // cache Object values in options && reset HTML\n\n\n      var htmlList = [containerHTML, controlsContainerHTML, prevButtonHTML, nextButtonHTML, navContainerHTML, autoplayButtonHTML];\n      tnsList.forEach(function (item, i) {\n        var el = item === 'container' ? outerWrapper : options[item];\n\n        if (typeof el === 'object' && el) {\n          var prevEl = el.previousElementSibling ? el.previousElementSibling : false,\n              parentEl = el.parentNode;\n          el.outerHTML = htmlList[i];\n          options[item] = prevEl ? prevEl.nextElementSibling : parentEl.firstElementChild;\n        }\n      }); // reset variables\n\n      tnsList = animateIn = animateOut = animateDelay = animateNormal = horizontal = outerWrapper = innerWrapper = container = containerParent = containerHTML = slideItems = slideCount = breakpointZone = windowWidth = autoWidth = fixedWidth = edgePadding = gutter = viewport = items = slideBy = viewportMax = arrowKeys = speed = rewind = loop = autoHeight = sheet = lazyload = slidePositions = slideItemsOut = cloneCount = slideCountNew = hasRightDeadZone = rightBoundary = updateIndexBeforeTransform = transformAttr = transformPrefix = transformPostfix = getIndexMax = index = indexCached = indexMin = indexMax = resizeTimer = swipeAngle = moveDirectionExpected = running = onInit = events = newContainerClasses = slideId = disable = disabled = freezable = freeze = frozen = controlsEvents = navEvents = hoverEvents = visibilityEvent = docmentKeydownEvent = touchEvents = dragEvents = hasControls = hasNav = navAsThumbnails = hasAutoplay = hasTouch = hasMouseDrag = slideActiveClass = imgCompleteClass = imgEvents = imgsComplete = controls = controlsText = controlsContainer = controlsContainerHTML = prevButton = nextButton = prevIsButton = nextIsButton = nav = navContainer = navContainerHTML = navItems = pages = pagesCached = navClicked = navCurrentIndex = navCurrentIndexCached = navActiveClass = navStr = navStrCurrent = autoplay = autoplayTimeout = autoplayDirection = autoplayText = autoplayHoverPause = autoplayButton = autoplayButtonHTML = autoplayResetOnVisibility = autoplayHtmlStrings = autoplayTimer = animating = autoplayHoverPaused = autoplayUserPaused = autoplayVisibilityPaused = initPosition = lastPosition = translateInit = disX = disY = panStart = rafIndex = getDist = touch = mouseDrag = null; // check variables\n      // [animateIn, animateOut, animateDelay, animateNormal, horizontal, outerWrapper, innerWrapper, container, containerParent, containerHTML, slideItems, slideCount, breakpointZone, windowWidth, autoWidth, fixedWidth, edgePadding, gutter, viewport, items, slideBy, viewportMax, arrowKeys, speed, rewind, loop, autoHeight, sheet, lazyload, slidePositions, slideItemsOut, cloneCount, slideCountNew, hasRightDeadZone, rightBoundary, updateIndexBeforeTransform, transformAttr, transformPrefix, transformPostfix, getIndexMax, index, indexCached, indexMin, indexMax, resizeTimer, swipeAngle, moveDirectionExpected, running, onInit, events, newContainerClasses, slideId, disable, disabled, freezable, freeze, frozen, controlsEvents, navEvents, hoverEvents, visibilityEvent, docmentKeydownEvent, touchEvents, dragEvents, hasControls, hasNav, navAsThumbnails, hasAutoplay, hasTouch, hasMouseDrag, slideActiveClass, imgCompleteClass, imgEvents, imgsComplete, controls, controlsText, controlsContainer, controlsContainerHTML, prevButton, nextButton, prevIsButton, nextIsButton, nav, navContainer, navContainerHTML, navItems, pages, pagesCached, navClicked, navCurrentIndex, navCurrentIndexCached, navActiveClass, navStr, navStrCurrent, autoplay, autoplayTimeout, autoplayDirection, autoplayText, autoplayHoverPause, autoplayButton, autoplayButtonHTML, autoplayResetOnVisibility, autoplayHtmlStrings, autoplayTimer, animating, autoplayHoverPaused, autoplayUserPaused, autoplayVisibilityPaused, initPosition, lastPosition, translateInit, disX, disY, panStart, rafIndex, getDist, touch, mouseDrag ].forEach(function(item) { if (item !== null) { console.log(item); } });\n\n      for (var a in this) {\n        if (a !== 'rebuild') {\n          this[a] = null;\n        }\n      }\n\n      isOn = false;\n    } // === ON RESIZE ===\n    // responsive || fixedWidth || autoWidth || !horizontal\n\n\n    function onResize(e) {\n      raf(function () {\n        resizeTasks(getEvent(e));\n      });\n    }\n\n    function resizeTasks(e) {\n      if (!isOn) {\n        return;\n      }\n\n      if (nested === 'outer') {\n        events.emit('outerResized', info(e));\n      }\n\n      windowWidth = getWindowWidth();\n      var bpChanged,\n          breakpointZoneTem = breakpointZone,\n          needContainerTransform = false;\n\n      if (responsive) {\n        setBreakpointZone();\n        bpChanged = breakpointZoneTem !== breakpointZone; // if (hasRightDeadZone) { needContainerTransform = true; } // *?\n\n        if (bpChanged) {\n          events.emit('newBreakpointStart', info(e));\n        }\n      }\n\n      var indChanged,\n          itemsChanged,\n          itemsTem = items,\n          disableTem = disable,\n          freezeTem = freeze,\n          arrowKeysTem = arrowKeys,\n          controlsTem = controls,\n          navTem = nav,\n          touchTem = touch,\n          mouseDragTem = mouseDrag,\n          autoplayTem = autoplay,\n          autoplayHoverPauseTem = autoplayHoverPause,\n          autoplayResetOnVisibilityTem = autoplayResetOnVisibility,\n          indexTem = index;\n\n      if (bpChanged) {\n        var fixedWidthTem = fixedWidth,\n            autoHeightTem = autoHeight,\n            controlsTextTem = controlsText,\n            centerTem = center,\n            autoplayTextTem = autoplayText;\n\n        if (!CSSMQ) {\n          var gutterTem = gutter,\n              edgePaddingTem = edgePadding;\n        }\n      } // get option:\n      // fixed width: viewport, fixedWidth, gutter => items\n      // others: window width => all variables\n      // all: items => slideBy\n\n\n      arrowKeys = getOption('arrowKeys');\n      controls = getOption('controls');\n      nav = getOption('nav');\n      touch = getOption('touch');\n      center = getOption('center');\n      mouseDrag = getOption('mouseDrag');\n      autoplay = getOption('autoplay');\n      autoplayHoverPause = getOption('autoplayHoverPause');\n      autoplayResetOnVisibility = getOption('autoplayResetOnVisibility');\n\n      if (bpChanged) {\n        disable = getOption('disable');\n        fixedWidth = getOption('fixedWidth');\n        speed = getOption('speed');\n        autoHeight = getOption('autoHeight');\n        controlsText = getOption('controlsText');\n        autoplayText = getOption('autoplayText');\n        autoplayTimeout = getOption('autoplayTimeout');\n\n        if (!CSSMQ) {\n          edgePadding = getOption('edgePadding');\n          gutter = getOption('gutter');\n        }\n      } // update options\n\n\n      resetVariblesWhenDisable(disable);\n      viewport = getViewportWidth(); // <= edgePadding, gutter\n\n      if ((!horizontal || autoWidth) && !disable) {\n        setSlidePositions();\n\n        if (!horizontal) {\n          updateContentWrapperHeight(); // <= setSlidePositions\n\n          needContainerTransform = true;\n        }\n      }\n\n      if (fixedWidth || autoWidth) {\n        rightBoundary = getRightBoundary(); // autoWidth: <= viewport, slidePositions, gutter\n        // fixedWidth: <= viewport, fixedWidth, gutter\n\n        indexMax = getIndexMax(); // autoWidth: <= rightBoundary, slidePositions\n        // fixedWidth: <= rightBoundary, fixedWidth, gutter\n      }\n\n      if (bpChanged || fixedWidth) {\n        items = getOption('items');\n        slideBy = getOption('slideBy');\n        itemsChanged = items !== itemsTem;\n\n        if (itemsChanged) {\n          if (!fixedWidth && !autoWidth) {\n            indexMax = getIndexMax();\n          } // <= items\n          // check index before transform in case\n          // slider reach the right edge then items become bigger\n\n\n          updateIndex();\n        }\n      }\n\n      if (bpChanged) {\n        if (disable !== disableTem) {\n          if (disable) {\n            disableSlider();\n          } else {\n            enableSlider(); // <= slidePositions, rightBoundary, indexMax\n          }\n        }\n      }\n\n      if (freezable && (bpChanged || fixedWidth || autoWidth)) {\n        freeze = getFreeze(); // <= autoWidth: slidePositions, gutter, viewport, rightBoundary\n        // <= fixedWidth: fixedWidth, gutter, rightBoundary\n        // <= others: items\n\n        if (freeze !== freezeTem) {\n          if (freeze) {\n            doContainerTransform(getContainerTransformValue(getStartIndex(0)));\n            freezeSlider();\n          } else {\n            unfreezeSlider();\n            needContainerTransform = true;\n          }\n        }\n      }\n\n      resetVariblesWhenDisable(disable || freeze); // controls, nav, touch, mouseDrag, arrowKeys, autoplay, autoplayHoverPause, autoplayResetOnVisibility\n\n      if (!autoplay) {\n        autoplayHoverPause = autoplayResetOnVisibility = false;\n      }\n\n      if (arrowKeys !== arrowKeysTem) {\n        arrowKeys ? addEvents(doc, docmentKeydownEvent) : removeEvents(doc, docmentKeydownEvent);\n      }\n\n      if (controls !== controlsTem) {\n        if (controls) {\n          if (controlsContainer) {\n            showElement(controlsContainer);\n          } else {\n            if (prevButton) {\n              showElement(prevButton);\n            }\n\n            if (nextButton) {\n              showElement(nextButton);\n            }\n          }\n        } else {\n          if (controlsContainer) {\n            hideElement(controlsContainer);\n          } else {\n            if (prevButton) {\n              hideElement(prevButton);\n            }\n\n            if (nextButton) {\n              hideElement(nextButton);\n            }\n          }\n        }\n      }\n\n      if (nav !== navTem) {\n        if (nav) {\n          showElement(navContainer);\n          updateNavVisibility();\n        } else {\n          hideElement(navContainer);\n        }\n      }\n\n      if (touch !== touchTem) {\n        touch ? addEvents(container, touchEvents, options.preventScrollOnTouch) : removeEvents(container, touchEvents);\n      }\n\n      if (mouseDrag !== mouseDragTem) {\n        mouseDrag ? addEvents(container, dragEvents) : removeEvents(container, dragEvents);\n      }\n\n      if (autoplay !== autoplayTem) {\n        if (autoplay) {\n          if (autoplayButton) {\n            showElement(autoplayButton);\n          }\n\n          if (!animating && !autoplayUserPaused) {\n            startAutoplay();\n          }\n        } else {\n          if (autoplayButton) {\n            hideElement(autoplayButton);\n          }\n\n          if (animating) {\n            stopAutoplay();\n          }\n        }\n      }\n\n      if (autoplayHoverPause !== autoplayHoverPauseTem) {\n        autoplayHoverPause ? addEvents(container, hoverEvents) : removeEvents(container, hoverEvents);\n      }\n\n      if (autoplayResetOnVisibility !== autoplayResetOnVisibilityTem) {\n        autoplayResetOnVisibility ? addEvents(doc, visibilityEvent) : removeEvents(doc, visibilityEvent);\n      }\n\n      if (bpChanged) {\n        if (fixedWidth !== fixedWidthTem || center !== centerTem) {\n          needContainerTransform = true;\n        }\n\n        if (autoHeight !== autoHeightTem) {\n          if (!autoHeight) {\n            innerWrapper.style.height = '';\n          }\n        }\n\n        if (controls && controlsText !== controlsTextTem) {\n          prevButton.innerHTML = controlsText[0];\n          nextButton.innerHTML = controlsText[1];\n        }\n\n        if (autoplayButton && autoplayText !== autoplayTextTem) {\n          var i = autoplay ? 1 : 0,\n              html = autoplayButton.innerHTML,\n              len = html.length - autoplayTextTem[i].length;\n\n          if (html.substring(len) === autoplayTextTem[i]) {\n            autoplayButton.innerHTML = html.substring(0, len) + autoplayText[i];\n          }\n        }\n      } else {\n        if (center && (fixedWidth || autoWidth)) {\n          needContainerTransform = true;\n        }\n      }\n\n      if (itemsChanged || fixedWidth && !autoWidth) {\n        pages = getPages();\n        updateNavVisibility();\n      }\n\n      indChanged = index !== indexTem;\n\n      if (indChanged) {\n        events.emit('indexChanged', info());\n        needContainerTransform = true;\n      } else if (itemsChanged) {\n        if (!indChanged) {\n          additionalUpdates();\n        }\n      } else if (fixedWidth || autoWidth) {\n        doLazyLoad();\n        updateSlideStatus();\n        updateLiveRegion();\n      }\n\n      if (itemsChanged && !carousel) {\n        updateGallerySlidePositions();\n      }\n\n      if (!disable && !freeze) {\n        // non-mediaqueries: IE8\n        if (bpChanged && !CSSMQ) {\n          // middle wrapper styles\n          // inner wrapper styles\n          if (edgePadding !== edgePaddingTem || gutter !== gutterTem) {\n            innerWrapper.style.cssText = getInnerWrapperStyles(edgePadding, gutter, fixedWidth, speed, autoHeight);\n          }\n\n          if (horizontal) {\n            // container styles\n            if (carousel) {\n              container.style.width = getContainerWidth(fixedWidth, gutter, items);\n            } // slide styles\n\n\n            var str = getSlideWidthStyle(fixedWidth, gutter, items) + getSlideGutterStyle(gutter); // remove the last line and\n            // add new styles\n\n            removeCSSRule(sheet, getCssRulesLength(sheet) - 1);\n            addCSSRule(sheet, '#' + slideId + ' > .tns-item', str, getCssRulesLength(sheet));\n          }\n        } // auto height\n\n\n        if (autoHeight) {\n          doAutoHeight();\n        }\n\n        if (needContainerTransform) {\n          doContainerTransformSilent();\n          indexCached = index;\n        }\n      }\n\n      if (bpChanged) {\n        events.emit('newBreakpointEnd', info(e));\n      }\n    } // === INITIALIZATION FUNCTIONS === //\n\n\n    function getFreeze() {\n      if (!fixedWidth && !autoWidth) {\n        var a = center ? items - (items - 1) / 2 : items;\n        return slideCount <= a;\n      }\n\n      var width = fixedWidth ? (fixedWidth + gutter) * slideCount : slidePositions[slideCount],\n          vp = edgePadding ? viewport + edgePadding * 2 : viewport + gutter;\n\n      if (center) {\n        vp -= fixedWidth ? (viewport - fixedWidth) / 2 : (viewport - (slidePositions[index + 1] - slidePositions[index] - gutter)) / 2;\n      }\n\n      return width <= vp;\n    }\n\n    function setBreakpointZone() {\n      breakpointZone = 0;\n\n      for (var bp in responsive) {\n        bp = parseInt(bp); // convert string to number\n\n        if (windowWidth >= bp) {\n          breakpointZone = bp;\n        }\n      }\n    } // (slideBy, indexMin, indexMax) => index\n\n\n    var updateIndex = function () {\n      return loop ? carousel ? // loop + carousel\n      function () {\n        var leftEdge = indexMin,\n            rightEdge = indexMax;\n        leftEdge += slideBy;\n        rightEdge -= slideBy; // adjust edges when has edge paddings\n        // or fixed-width slider with extra space on the right side\n\n        if (edgePadding) {\n          leftEdge += 1;\n          rightEdge -= 1;\n        } else if (fixedWidth) {\n          if ((viewport + gutter) % (fixedWidth + gutter)) {\n            rightEdge -= 1;\n          }\n        }\n\n        if (cloneCount) {\n          if (index > rightEdge) {\n            index -= slideCount;\n          } else if (index < leftEdge) {\n            index += slideCount;\n          }\n        }\n      } : // loop + gallery\n      function () {\n        if (index > indexMax) {\n          while (index >= indexMin + slideCount) {\n            index -= slideCount;\n          }\n        } else if (index < indexMin) {\n          while (index <= indexMax - slideCount) {\n            index += slideCount;\n          }\n        }\n      } : // non-loop\n      function () {\n        index = Math.max(indexMin, Math.min(indexMax, index));\n      };\n    }();\n\n    function disableUI() {\n      if (!autoplay && autoplayButton) {\n        hideElement(autoplayButton);\n      }\n\n      if (!nav && navContainer) {\n        hideElement(navContainer);\n      }\n\n      if (!controls) {\n        if (controlsContainer) {\n          hideElement(controlsContainer);\n        } else {\n          if (prevButton) {\n            hideElement(prevButton);\n          }\n\n          if (nextButton) {\n            hideElement(nextButton);\n          }\n        }\n      }\n    }\n\n    function enableUI() {\n      if (autoplay && autoplayButton) {\n        showElement(autoplayButton);\n      }\n\n      if (nav && navContainer) {\n        showElement(navContainer);\n      }\n\n      if (controls) {\n        if (controlsContainer) {\n          showElement(controlsContainer);\n        } else {\n          if (prevButton) {\n            showElement(prevButton);\n          }\n\n          if (nextButton) {\n            showElement(nextButton);\n          }\n        }\n      }\n    }\n\n    function freezeSlider() {\n      if (frozen) {\n        return;\n      } // remove edge padding from inner wrapper\n\n\n      if (edgePadding) {\n        innerWrapper.style.margin = '0px';\n      } // add class tns-transparent to cloned slides\n\n\n      if (cloneCount) {\n        var str = 'tns-transparent';\n\n        for (var i = cloneCount; i--;) {\n          if (carousel) {\n            addClass(slideItems[i], str);\n          }\n\n          addClass(slideItems[slideCountNew - i - 1], str);\n        }\n      } // update tools\n\n\n      disableUI();\n      frozen = true;\n    }\n\n    function unfreezeSlider() {\n      if (!frozen) {\n        return;\n      } // restore edge padding for inner wrapper\n      // for mordern browsers\n\n\n      if (edgePadding && CSSMQ) {\n        innerWrapper.style.margin = '';\n      } // remove class tns-transparent to cloned slides\n\n\n      if (cloneCount) {\n        var str = 'tns-transparent';\n\n        for (var i = cloneCount; i--;) {\n          if (carousel) {\n            removeClass(slideItems[i], str);\n          }\n\n          removeClass(slideItems[slideCountNew - i - 1], str);\n        }\n      } // update tools\n\n\n      enableUI();\n      frozen = false;\n    }\n\n    function disableSlider() {\n      if (disabled) {\n        return;\n      }\n\n      sheet.disabled = true;\n      container.className = container.className.replace(newContainerClasses.substring(1), '');\n      removeAttrs(container, ['style']);\n\n      if (loop) {\n        for (var j = cloneCount; j--;) {\n          if (carousel) {\n            hideElement(slideItems[j]);\n          }\n\n          hideElement(slideItems[slideCountNew - j - 1]);\n        }\n      } // vertical slider\n\n\n      if (!horizontal || !carousel) {\n        removeAttrs(innerWrapper, ['style']);\n      } // gallery\n\n\n      if (!carousel) {\n        for (var i = index, l = index + slideCount; i < l; i++) {\n          var item = slideItems[i];\n          removeAttrs(item, ['style']);\n          removeClass(item, animateIn);\n          removeClass(item, animateNormal);\n        }\n      } // update tools\n\n\n      disableUI();\n      disabled = true;\n    }\n\n    function enableSlider() {\n      if (!disabled) {\n        return;\n      }\n\n      sheet.disabled = false;\n      container.className += newContainerClasses;\n      doContainerTransformSilent();\n\n      if (loop) {\n        for (var j = cloneCount; j--;) {\n          if (carousel) {\n            showElement(slideItems[j]);\n          }\n\n          showElement(slideItems[slideCountNew - j - 1]);\n        }\n      } // gallery\n\n\n      if (!carousel) {\n        for (var i = index, l = index + slideCount; i < l; i++) {\n          var item = slideItems[i],\n              classN = i < index + items ? animateIn : animateNormal;\n          item.style.left = (i - index) * 100 / items + '%';\n          addClass(item, classN);\n        }\n      } // update tools\n\n\n      enableUI();\n      disabled = false;\n    }\n\n    function updateLiveRegion() {\n      var str = getLiveRegionStr();\n\n      if (liveregionCurrent.innerHTML !== str) {\n        liveregionCurrent.innerHTML = str;\n      }\n    }\n\n    function getLiveRegionStr() {\n      var arr = getVisibleSlideRange(),\n          start = arr[0] + 1,\n          end = arr[1] + 1;\n      return start === end ? start + '' : start + ' to ' + end;\n    }\n\n    function getVisibleSlideRange(val) {\n      if (val == null) {\n        val = getContainerTransformValue();\n      }\n\n      var start = index,\n          end,\n          rangestart,\n          rangeend; // get range start, range end for autoWidth and fixedWidth\n\n      if (center || edgePadding) {\n        if (autoWidth || fixedWidth) {\n          rangestart = -(parseFloat(val) + edgePadding);\n          rangeend = rangestart + viewport + edgePadding * 2;\n        }\n      } else {\n        if (autoWidth) {\n          rangestart = slidePositions[index];\n          rangeend = rangestart + viewport;\n        }\n      } // get start, end\n      // - check auto width\n\n\n      if (autoWidth) {\n        slidePositions.forEach(function (point, i) {\n          if (i < slideCountNew) {\n            if ((center || edgePadding) && point <= rangestart + 0.5) {\n              start = i;\n            }\n\n            if (rangeend - point >= 0.5) {\n              end = i;\n            }\n          }\n        }); // - check percentage width, fixed width\n      } else {\n        if (fixedWidth) {\n          var cell = fixedWidth + gutter;\n\n          if (center || edgePadding) {\n            start = Math.floor(rangestart / cell);\n            end = Math.ceil(rangeend / cell - 1);\n          } else {\n            end = start + Math.ceil(viewport / cell) - 1;\n          }\n        } else {\n          if (center || edgePadding) {\n            var a = items - 1;\n\n            if (center) {\n              start -= a / 2;\n              end = index + a / 2;\n            } else {\n              end = index + a;\n            }\n\n            if (edgePadding) {\n              var b = edgePadding * items / viewport;\n              start -= b;\n              end += b;\n            }\n\n            start = Math.floor(start);\n            end = Math.ceil(end);\n          } else {\n            end = start + items - 1;\n          }\n        }\n\n        start = Math.max(start, 0);\n        end = Math.min(end, slideCountNew - 1);\n      }\n\n      return [start, end];\n    }\n\n    function doLazyLoad() {\n      if (lazyload && !disable) {\n        var arg = getVisibleSlideRange();\n        arg.push(lazyloadSelector);\n        getImageArray.apply(null, arg).forEach(function (img) {\n          if (!hasClass(img, imgCompleteClass)) {\n            // stop propagation transitionend event to container\n            var eve = {};\n\n            eve[TRANSITIONEND] = function (e) {\n              e.stopPropagation();\n            };\n\n            addEvents(img, eve);\n            addEvents(img, imgEvents); // update src\n\n            img.src = getAttr(img, 'data-src'); // update srcset\n\n            var srcset = getAttr(img, 'data-srcset');\n\n            if (srcset) {\n              img.srcset = srcset;\n            }\n\n            addClass(img, 'loading');\n          }\n        });\n      }\n    }\n\n    function onImgLoaded(e) {\n      imgLoaded(getTarget(e));\n    }\n\n    function onImgFailed(e) {\n      imgFailed(getTarget(e));\n    }\n\n    function imgLoaded(img) {\n      addClass(img, 'loaded');\n      imgCompleted(img);\n    }\n\n    function imgFailed(img) {\n      addClass(img, 'failed');\n      imgCompleted(img);\n    }\n\n    function imgCompleted(img) {\n      addClass(img, imgCompleteClass);\n      removeClass(img, 'loading');\n      removeEvents(img, imgEvents);\n    }\n\n    function getImageArray(start, end, imgSelector) {\n      var imgs = [];\n\n      if (!imgSelector) {\n        imgSelector = 'img';\n      }\n\n      while (start <= end) {\n        forEach(slideItems[start].querySelectorAll(imgSelector), function (img) {\n          imgs.push(img);\n        });\n        start++;\n      }\n\n      return imgs;\n    } // check if all visible images are loaded\n    // and update container height if it's done\n\n\n    function doAutoHeight() {\n      var imgs = getImageArray.apply(null, getVisibleSlideRange());\n      raf(function () {\n        imgsLoadedCheck(imgs, updateInnerWrapperHeight);\n      });\n    }\n\n    function imgsLoadedCheck(imgs, cb) {\n      // execute callback function if all images are complete\n      if (imgsComplete) {\n        return cb();\n      } // check image classes\n\n\n      imgs.forEach(function (img, index) {\n        if (!lazyload && img.complete) {\n          imgCompleted(img);\n        } // Check image.complete\n\n\n        if (hasClass(img, imgCompleteClass)) {\n          imgs.splice(index, 1);\n        }\n      }); // execute callback function if selected images are all complete\n\n      if (!imgs.length) {\n        return cb();\n      } // otherwise execute this functiona again\n\n\n      raf(function () {\n        imgsLoadedCheck(imgs, cb);\n      });\n    }\n\n    function additionalUpdates() {\n      doLazyLoad();\n      updateSlideStatus();\n      updateLiveRegion();\n      updateControlsStatus();\n      updateNavStatus();\n    }\n\n    function update_carousel_transition_duration() {\n      if (carousel && autoHeight) {\n        middleWrapper.style[TRANSITIONDURATION] = speed / 1000 + 's';\n      }\n    }\n\n    function getMaxSlideHeight(slideStart, slideRange) {\n      var heights = [];\n\n      for (var i = slideStart, l = Math.min(slideStart + slideRange, slideCountNew); i < l; i++) {\n        heights.push(slideItems[i].offsetHeight);\n      }\n\n      return Math.max.apply(null, heights);\n    } // update inner wrapper height\n    // 1. get the max-height of the visible slides\n    // 2. set transitionDuration to speed\n    // 3. update inner wrapper height to max-height\n    // 4. set transitionDuration to 0s after transition done\n\n\n    function updateInnerWrapperHeight() {\n      var maxHeight = autoHeight ? getMaxSlideHeight(index, items) : getMaxSlideHeight(cloneCount, slideCount),\n          wp = middleWrapper ? middleWrapper : innerWrapper;\n\n      if (wp.style.height !== maxHeight) {\n        wp.style.height = maxHeight + 'px';\n      }\n    } // get the distance from the top edge of the first slide to each slide\n    // (init) => slidePositions\n\n\n    function setSlidePositions() {\n      slidePositions = [0];\n      var attr = horizontal ? 'left' : 'top',\n          attr2 = horizontal ? 'right' : 'bottom',\n          base = slideItems[0].getBoundingClientRect()[attr];\n      forEach(slideItems, function (item, i) {\n        // skip the first slide\n        if (i) {\n          slidePositions.push(item.getBoundingClientRect()[attr] - base);\n        } // add the end edge\n\n\n        if (i === slideCountNew - 1) {\n          slidePositions.push(item.getBoundingClientRect()[attr2] - base);\n        }\n      });\n    } // update slide\n\n\n    function updateSlideStatus() {\n      var range = getVisibleSlideRange(),\n          start = range[0],\n          end = range[1];\n      forEach(slideItems, function (item, i) {\n        // show slides\n        if (i >= start && i <= end) {\n          if (hasAttr(item, 'aria-hidden')) {\n            removeAttrs(item, ['aria-hidden', 'tabindex']);\n            addClass(item, slideActiveClass);\n          } // hide slides\n\n        } else {\n          if (!hasAttr(item, 'aria-hidden')) {\n            setAttrs(item, {\n              'aria-hidden': 'true',\n              'tabindex': '-1'\n            });\n            removeClass(item, slideActiveClass);\n          }\n        }\n      });\n    } // gallery: update slide position\n\n\n    function updateGallerySlidePositions() {\n      var l = index + Math.min(slideCount, items);\n\n      for (var i = slideCountNew; i--;) {\n        var item = slideItems[i];\n\n        if (i >= index && i < l) {\n          // add transitions to visible slides when adjusting their positions\n          addClass(item, 'tns-moving');\n          item.style.left = (i - index) * 100 / items + '%';\n          addClass(item, animateIn);\n          removeClass(item, animateNormal);\n        } else if (item.style.left) {\n          item.style.left = '';\n          addClass(item, animateNormal);\n          removeClass(item, animateIn);\n        } // remove outlet animation\n\n\n        removeClass(item, animateOut);\n      } // removing '.tns-moving'\n\n\n      setTimeout(function () {\n        forEach(slideItems, function (el) {\n          removeClass(el, 'tns-moving');\n        });\n      }, 300);\n    } // set tabindex on Nav\n\n\n    function updateNavStatus() {\n      // get current nav\n      if (nav) {\n        navCurrentIndex = navClicked >= 0 ? navClicked : getCurrentNavIndex();\n        navClicked = -1;\n\n        if (navCurrentIndex !== navCurrentIndexCached) {\n          var navPrev = navItems[navCurrentIndexCached],\n              navCurrent = navItems[navCurrentIndex];\n          setAttrs(navPrev, {\n            'tabindex': '-1',\n            'aria-label': navStr + (navCurrentIndexCached + 1)\n          });\n          removeClass(navPrev, navActiveClass);\n          setAttrs(navCurrent, {\n            'aria-label': navStr + (navCurrentIndex + 1) + navStrCurrent\n          });\n          removeAttrs(navCurrent, 'tabindex');\n          addClass(navCurrent, navActiveClass);\n          navCurrentIndexCached = navCurrentIndex;\n        }\n      }\n    }\n\n    function getLowerCaseNodeName(el) {\n      return el.nodeName.toLowerCase();\n    }\n\n    function isButton(el) {\n      return getLowerCaseNodeName(el) === 'button';\n    }\n\n    function isAriaDisabled(el) {\n      return el.getAttribute('aria-disabled') === 'true';\n    }\n\n    function disEnableElement(isButton, el, val) {\n      if (isButton) {\n        el.disabled = val;\n      } else {\n        el.setAttribute('aria-disabled', val.toString());\n      }\n    } // set 'disabled' to true on controls when reach the edges\n\n\n    function updateControlsStatus() {\n      if (!controls || rewind || loop) {\n        return;\n      }\n\n      var prevDisabled = prevIsButton ? prevButton.disabled : isAriaDisabled(prevButton),\n          nextDisabled = nextIsButton ? nextButton.disabled : isAriaDisabled(nextButton),\n          disablePrev = index <= indexMin ? true : false,\n          disableNext = !rewind && index >= indexMax ? true : false;\n\n      if (disablePrev && !prevDisabled) {\n        disEnableElement(prevIsButton, prevButton, true);\n      }\n\n      if (!disablePrev && prevDisabled) {\n        disEnableElement(prevIsButton, prevButton, false);\n      }\n\n      if (disableNext && !nextDisabled) {\n        disEnableElement(nextIsButton, nextButton, true);\n      }\n\n      if (!disableNext && nextDisabled) {\n        disEnableElement(nextIsButton, nextButton, false);\n      }\n    } // set duration\n\n\n    function resetDuration(el, str) {\n      if (TRANSITIONDURATION) {\n        el.style[TRANSITIONDURATION] = str;\n      }\n    }\n\n    function getSliderWidth() {\n      return fixedWidth ? (fixedWidth + gutter) * slideCountNew : slidePositions[slideCountNew];\n    }\n\n    function getCenterGap(num) {\n      if (num == null) {\n        num = index;\n      }\n\n      var gap = edgePadding ? gutter : 0;\n      return autoWidth ? (viewport - gap - (slidePositions[num + 1] - slidePositions[num] - gutter)) / 2 : fixedWidth ? (viewport - fixedWidth) / 2 : (items - 1) / 2;\n    }\n\n    function getRightBoundary() {\n      var gap = edgePadding ? gutter : 0,\n          result = viewport + gap - getSliderWidth();\n\n      if (center && !loop) {\n        result = fixedWidth ? -(fixedWidth + gutter) * (slideCountNew - 1) - getCenterGap() : getCenterGap(slideCountNew - 1) - slidePositions[slideCountNew - 1];\n      }\n\n      if (result > 0) {\n        result = 0;\n      }\n\n      return result;\n    }\n\n    function getContainerTransformValue(num) {\n      if (num == null) {\n        num = index;\n      }\n\n      var val;\n\n      if (horizontal && !autoWidth) {\n        if (fixedWidth) {\n          val = -(fixedWidth + gutter) * num;\n\n          if (center) {\n            val += getCenterGap();\n          }\n        } else {\n          var denominator = TRANSFORM ? slideCountNew : items;\n\n          if (center) {\n            num -= getCenterGap();\n          }\n\n          val = -num * 100 / denominator;\n        }\n      } else {\n        val = -slidePositions[num];\n\n        if (center && autoWidth) {\n          val += getCenterGap();\n        }\n      }\n\n      if (hasRightDeadZone) {\n        val = Math.max(val, rightBoundary);\n      }\n\n      val += horizontal && !autoWidth && !fixedWidth ? '%' : 'px';\n      return val;\n    }\n\n    function doContainerTransformSilent(val) {\n      resetDuration(container, '0s');\n      doContainerTransform(val);\n    }\n\n    function doContainerTransform(val) {\n      if (val == null) {\n        val = getContainerTransformValue();\n      }\n\n      container.style[transformAttr] = transformPrefix + val + transformPostfix;\n    }\n\n    function animateSlide(number, classOut, classIn, isOut) {\n      var l = number + items;\n\n      if (!loop) {\n        l = Math.min(l, slideCountNew);\n      }\n\n      for (var i = number; i < l; i++) {\n        var item = slideItems[i]; // set item positions\n\n        if (!isOut) {\n          item.style.left = (i - index) * 100 / items + '%';\n        }\n\n        if (animateDelay && TRANSITIONDELAY) {\n          item.style[TRANSITIONDELAY] = item.style[ANIMATIONDELAY] = animateDelay * (i - number) / 1000 + 's';\n        }\n\n        removeClass(item, classOut);\n        addClass(item, classIn);\n\n        if (isOut) {\n          slideItemsOut.push(item);\n        }\n      }\n    } // make transfer after click/drag:\n    // 1. change 'transform' property for mordern browsers\n    // 2. change 'left' property for legacy browsers\n\n\n    var transformCore = function () {\n      return carousel ? function () {\n        resetDuration(container, '');\n\n        if (TRANSITIONDURATION || !speed) {\n          // for morden browsers with non-zero duration or\n          // zero duration for all browsers\n          doContainerTransform(); // run fallback function manually\n          // when duration is 0 / container is hidden\n\n          if (!speed || !isVisible(container)) {\n            onTransitionEnd();\n          }\n        } else {\n          // for old browser with non-zero duration\n          jsTransform(container, transformAttr, transformPrefix, transformPostfix, getContainerTransformValue(), speed, onTransitionEnd);\n        }\n\n        if (!horizontal) {\n          updateContentWrapperHeight();\n        }\n      } : function () {\n        slideItemsOut = [];\n        var eve = {};\n        eve[TRANSITIONEND] = eve[ANIMATIONEND] = onTransitionEnd;\n        removeEvents(slideItems[indexCached], eve);\n        addEvents(slideItems[index], eve);\n        animateSlide(indexCached, animateIn, animateOut, true);\n        animateSlide(index, animateNormal, animateIn); // run fallback function manually\n        // when transition or animation not supported / duration is 0\n\n        if (!TRANSITIONEND || !ANIMATIONEND || !speed || !isVisible(container)) {\n          onTransitionEnd();\n        }\n      };\n    }();\n\n    function render(e, sliderMoved) {\n      if (updateIndexBeforeTransform) {\n        updateIndex();\n      } // render when slider was moved (touch or drag) even though index may not change\n\n\n      if (index !== indexCached || sliderMoved) {\n        // events\n        events.emit('indexChanged', info());\n        events.emit('transitionStart', info());\n\n        if (autoHeight) {\n          doAutoHeight();\n        } // pause autoplay when click or keydown from user\n\n\n        if (animating && e && ['click', 'keydown'].indexOf(e.type) >= 0) {\n          stopAutoplay();\n        }\n\n        running = true;\n        transformCore();\n      }\n    }\n    /*\n     * Transfer prefixed properties to the same format\n     * CSS: -Webkit-Transform => webkittransform\n     * JS: WebkitTransform => webkittransform\n     * @param {string} str - property\n     *\n     */\n\n\n    function strTrans(str) {\n      return str.toLowerCase().replace(/-/g, '');\n    } // AFTER TRANSFORM\n    // Things need to be done after a transfer:\n    // 1. check index\n    // 2. add classes to visible slide\n    // 3. disable controls buttons when reach the first/last slide in non-loop slider\n    // 4. update nav status\n    // 5. lazyload images\n    // 6. update container height\n\n\n    function onTransitionEnd(event) {\n      // check running on gallery mode\n      // make sure trantionend/animationend events run only once\n      if (carousel || running) {\n        events.emit('transitionEnd', info(event));\n\n        if (!carousel && slideItemsOut.length > 0) {\n          for (var i = 0; i < slideItemsOut.length; i++) {\n            var item = slideItemsOut[i]; // set item positions\n\n            item.style.left = '';\n\n            if (ANIMATIONDELAY && TRANSITIONDELAY) {\n              item.style[ANIMATIONDELAY] = '';\n              item.style[TRANSITIONDELAY] = '';\n            }\n\n            removeClass(item, animateOut);\n            addClass(item, animateNormal);\n          }\n        }\n        /* update slides, nav, controls after checking ...\n         * => legacy browsers who don't support 'event'\n         *    have to check event first, otherwise event.target will cause an error\n         * => or 'gallery' mode:\n         *   + event target is slide item\n         * => or 'carousel' mode:\n         *   + event target is container,\n         *   + event.property is the same with transform attribute\n         */\n\n\n        if (!event || !carousel && event.target.parentNode === container || event.target === container && strTrans(event.propertyName) === strTrans(transformAttr)) {\n          if (!updateIndexBeforeTransform) {\n            var indexTem = index;\n            updateIndex();\n\n            if (index !== indexTem) {\n              events.emit('indexChanged', info());\n              doContainerTransformSilent();\n            }\n          }\n\n          if (nested === 'inner') {\n            events.emit('innerLoaded', info());\n          }\n\n          running = false;\n          indexCached = index;\n        }\n      }\n    } // # ACTIONS\n\n\n    function goTo(targetIndex, e) {\n      if (freeze) {\n        return;\n      } // prev slideBy\n\n\n      if (targetIndex === 'prev') {\n        onControlsClick(e, -1); // next slideBy\n      } else if (targetIndex === 'next') {\n        onControlsClick(e, 1); // go to exact slide\n      } else {\n        if (running) {\n          if (preventActionWhenRunning) {\n            return;\n          } else {\n            onTransitionEnd();\n          }\n        }\n\n        var absIndex = getAbsIndex(),\n            indexGap = 0;\n\n        if (targetIndex === 'first') {\n          indexGap = -absIndex;\n        } else if (targetIndex === 'last') {\n          indexGap = carousel ? slideCount - items - absIndex : slideCount - 1 - absIndex;\n        } else {\n          if (typeof targetIndex !== 'number') {\n            targetIndex = parseInt(targetIndex);\n          }\n\n          if (!isNaN(targetIndex)) {\n            // from directly called goTo function\n            if (!e) {\n              targetIndex = Math.max(0, Math.min(slideCount - 1, targetIndex));\n            }\n\n            indexGap = targetIndex - absIndex;\n          }\n        } // gallery: make sure new page won't overlap with current page\n\n\n        if (!carousel && indexGap && Math.abs(indexGap) < items) {\n          var factor = indexGap > 0 ? 1 : -1;\n          indexGap += index + indexGap - slideCount >= indexMin ? slideCount * factor : slideCount * 2 * factor * -1;\n        }\n\n        index += indexGap; // make sure index is in range\n\n        if (carousel && loop) {\n          if (index < indexMin) {\n            index += slideCount;\n          }\n\n          if (index > indexMax) {\n            index -= slideCount;\n          }\n        } // if index is changed, start rendering\n\n\n        if (getAbsIndex(index) !== getAbsIndex(indexCached)) {\n          render(e);\n        }\n      }\n    } // on controls click\n\n\n    function onControlsClick(e, dir) {\n      if (running) {\n        if (preventActionWhenRunning) {\n          return;\n        } else {\n          onTransitionEnd();\n        }\n      }\n\n      var passEventObject;\n\n      if (!dir) {\n        e = getEvent(e);\n        var target = getTarget(e);\n\n        while (target !== controlsContainer && [prevButton, nextButton].indexOf(target) < 0) {\n          target = target.parentNode;\n        }\n\n        var targetIn = [prevButton, nextButton].indexOf(target);\n\n        if (targetIn >= 0) {\n          passEventObject = true;\n          dir = targetIn === 0 ? -1 : 1;\n        }\n      }\n\n      if (rewind) {\n        if (index === indexMin && dir === -1) {\n          goTo('last', e);\n          return;\n        } else if (index === indexMax && dir === 1) {\n          goTo('first', e);\n          return;\n        }\n      }\n\n      if (dir) {\n        index += slideBy * dir;\n\n        if (autoWidth) {\n          index = Math.floor(index);\n        } // pass e when click control buttons or keydown\n\n\n        render(passEventObject || e && e.type === 'keydown' ? e : null);\n      }\n    } // on nav click\n\n\n    function onNavClick(e) {\n      if (running) {\n        if (preventActionWhenRunning) {\n          return;\n        } else {\n          onTransitionEnd();\n        }\n      }\n\n      e = getEvent(e);\n      var target = getTarget(e),\n          navIndex; // find the clicked nav item\n\n      while (target !== navContainer && !hasAttr(target, 'data-nav')) {\n        target = target.parentNode;\n      }\n\n      if (hasAttr(target, 'data-nav')) {\n        var navIndex = navClicked = Number(getAttr(target, 'data-nav')),\n            targetIndexBase = fixedWidth || autoWidth ? navIndex * slideCount / pages : navIndex * items,\n            targetIndex = navAsThumbnails ? navIndex : Math.min(Math.ceil(targetIndexBase), slideCount - 1);\n        goTo(targetIndex, e);\n\n        if (navCurrentIndex === navIndex) {\n          if (animating) {\n            stopAutoplay();\n          }\n\n          navClicked = -1; // reset navClicked\n        }\n      }\n    } // autoplay functions\n\n\n    function setAutoplayTimer() {\n      autoplayTimer = setInterval(function () {\n        onControlsClick(null, autoplayDirection);\n      }, autoplayTimeout);\n      animating = true;\n    }\n\n    function stopAutoplayTimer() {\n      clearInterval(autoplayTimer);\n      animating = false;\n    }\n\n    function updateAutoplayButton(action, txt) {\n      setAttrs(autoplayButton, {\n        'data-action': action\n      });\n      autoplayButton.innerHTML = autoplayHtmlStrings[0] + action + autoplayHtmlStrings[1] + txt;\n    }\n\n    function startAutoplay() {\n      setAutoplayTimer();\n\n      if (autoplayButton) {\n        updateAutoplayButton('stop', autoplayText[1]);\n      }\n    }\n\n    function stopAutoplay() {\n      stopAutoplayTimer();\n\n      if (autoplayButton) {\n        updateAutoplayButton('start', autoplayText[0]);\n      }\n    } // programaitcally play/pause the slider\n\n\n    function play() {\n      if (autoplay && !animating) {\n        startAutoplay();\n        autoplayUserPaused = false;\n      }\n    }\n\n    function pause() {\n      if (animating) {\n        stopAutoplay();\n        autoplayUserPaused = true;\n      }\n    }\n\n    function toggleAutoplay() {\n      if (animating) {\n        stopAutoplay();\n        autoplayUserPaused = true;\n      } else {\n        startAutoplay();\n        autoplayUserPaused = false;\n      }\n    }\n\n    function onVisibilityChange() {\n      if (doc.hidden) {\n        if (animating) {\n          stopAutoplayTimer();\n          autoplayVisibilityPaused = true;\n        }\n      } else if (autoplayVisibilityPaused) {\n        setAutoplayTimer();\n        autoplayVisibilityPaused = false;\n      }\n    }\n\n    function mouseoverPause() {\n      if (animating) {\n        stopAutoplayTimer();\n        autoplayHoverPaused = true;\n      }\n    }\n\n    function mouseoutRestart() {\n      if (autoplayHoverPaused) {\n        setAutoplayTimer();\n        autoplayHoverPaused = false;\n      }\n    } // keydown events on document\n\n\n    function onDocumentKeydown(e) {\n      e = getEvent(e);\n      var keyIndex = [KEYS.LEFT, KEYS.RIGHT].indexOf(e.keyCode);\n\n      if (keyIndex >= 0) {\n        onControlsClick(e, keyIndex === 0 ? -1 : 1);\n      }\n    } // on key control\n\n\n    function onControlsKeydown(e) {\n      e = getEvent(e);\n      var keyIndex = [KEYS.LEFT, KEYS.RIGHT].indexOf(e.keyCode);\n\n      if (keyIndex >= 0) {\n        if (keyIndex === 0) {\n          if (!prevButton.disabled) {\n            onControlsClick(e, -1);\n          }\n        } else if (!nextButton.disabled) {\n          onControlsClick(e, 1);\n        }\n      }\n    } // set focus\n\n\n    function setFocus(el) {\n      el.focus();\n    } // on key nav\n\n\n    function onNavKeydown(e) {\n      e = getEvent(e);\n      var curElement = doc.activeElement;\n\n      if (!hasAttr(curElement, 'data-nav')) {\n        return;\n      } // var code = e.keyCode,\n\n\n      var keyIndex = [KEYS.LEFT, KEYS.RIGHT, KEYS.ENTER, KEYS.SPACE].indexOf(e.keyCode),\n          navIndex = Number(getAttr(curElement, 'data-nav'));\n\n      if (keyIndex >= 0) {\n        if (keyIndex === 0) {\n          if (navIndex > 0) {\n            setFocus(navItems[navIndex - 1]);\n          }\n        } else if (keyIndex === 1) {\n          if (navIndex < pages - 1) {\n            setFocus(navItems[navIndex + 1]);\n          }\n        } else {\n          navClicked = navIndex;\n          goTo(navIndex, e);\n        }\n      }\n    }\n\n    function getEvent(e) {\n      e = e || win.event;\n      return isTouchEvent(e) ? e.changedTouches[0] : e;\n    }\n\n    function getTarget(e) {\n      return e.target || win.event.srcElement;\n    }\n\n    function isTouchEvent(e) {\n      return e.type.indexOf('touch') >= 0;\n    }\n\n    function preventDefaultBehavior(e) {\n      e.preventDefault ? e.preventDefault() : e.returnValue = false;\n    }\n\n    function getMoveDirectionExpected() {\n      return getTouchDirection(toDegree(lastPosition.y - initPosition.y, lastPosition.x - initPosition.x), swipeAngle) === options.axis;\n    }\n\n    function onPanStart(e) {\n      if (running) {\n        if (preventActionWhenRunning) {\n          return;\n        } else {\n          onTransitionEnd();\n        }\n      }\n\n      if (autoplay && animating) {\n        stopAutoplayTimer();\n      }\n\n      panStart = true;\n\n      if (rafIndex) {\n        caf(rafIndex);\n        rafIndex = null;\n      }\n\n      var $ = getEvent(e);\n      events.emit(isTouchEvent(e) ? 'touchStart' : 'dragStart', info(e));\n\n      if (!isTouchEvent(e) && ['img', 'a'].indexOf(getLowerCaseNodeName(getTarget(e))) >= 0) {\n        preventDefaultBehavior(e);\n      }\n\n      lastPosition.x = initPosition.x = $.clientX;\n      lastPosition.y = initPosition.y = $.clientY;\n\n      if (carousel) {\n        translateInit = parseFloat(container.style[transformAttr].replace(transformPrefix, ''));\n        resetDuration(container, '0s');\n      }\n    }\n\n    function onPanMove(e) {\n      if (panStart) {\n        var $ = getEvent(e);\n        lastPosition.x = $.clientX;\n        lastPosition.y = $.clientY;\n\n        if (carousel) {\n          if (!rafIndex) {\n            rafIndex = raf(function () {\n              panUpdate(e);\n            });\n          }\n        } else {\n          if (moveDirectionExpected === '?') {\n            moveDirectionExpected = getMoveDirectionExpected();\n          }\n\n          if (moveDirectionExpected) {\n            preventScroll = true;\n          }\n        }\n\n        if ((typeof e.cancelable !== 'boolean' || e.cancelable) && preventScroll) {\n          e.preventDefault();\n        }\n      }\n    }\n\n    function panUpdate(e) {\n      if (!moveDirectionExpected) {\n        panStart = false;\n        return;\n      }\n\n      caf(rafIndex);\n\n      if (panStart) {\n        rafIndex = raf(function () {\n          panUpdate(e);\n        });\n      }\n\n      if (moveDirectionExpected === '?') {\n        moveDirectionExpected = getMoveDirectionExpected();\n      }\n\n      if (moveDirectionExpected) {\n        if (!preventScroll && isTouchEvent(e)) {\n          preventScroll = true;\n        }\n\n        try {\n          if (e.type) {\n            events.emit(isTouchEvent(e) ? 'touchMove' : 'dragMove', info(e));\n          }\n        } catch (err) {}\n\n        var x = translateInit,\n            dist = getDist(lastPosition, initPosition);\n\n        if (!horizontal || fixedWidth || autoWidth) {\n          x += dist;\n          x += 'px';\n        } else {\n          var percentageX = TRANSFORM ? dist * items * 100 / ((viewport + gutter) * slideCountNew) : dist * 100 / (viewport + gutter);\n          x += percentageX;\n          x += '%';\n        }\n\n        container.style[transformAttr] = transformPrefix + x + transformPostfix;\n      }\n    }\n\n    function onPanEnd(e) {\n      if (panStart) {\n        if (rafIndex) {\n          caf(rafIndex);\n          rafIndex = null;\n        }\n\n        if (carousel) {\n          resetDuration(container, '');\n        }\n\n        panStart = false;\n        var $ = getEvent(e);\n        lastPosition.x = $.clientX;\n        lastPosition.y = $.clientY;\n        var dist = getDist(lastPosition, initPosition);\n\n        if (Math.abs(dist)) {\n          // drag vs click\n          if (!isTouchEvent(e)) {\n            // prevent \"click\"\n            var target = getTarget(e);\n            addEvents(target, {\n              'click': function preventClick(e) {\n                preventDefaultBehavior(e);\n                removeEvents(target, {\n                  'click': preventClick\n                });\n              }\n            });\n          }\n\n          if (carousel) {\n            rafIndex = raf(function () {\n              if (horizontal && !autoWidth) {\n                var indexMoved = -dist * items / (viewport + gutter);\n                indexMoved = dist > 0 ? Math.floor(indexMoved) : Math.ceil(indexMoved);\n                index += indexMoved;\n              } else {\n                var moved = -(translateInit + dist);\n\n                if (moved <= 0) {\n                  index = indexMin;\n                } else if (moved >= slidePositions[slideCountNew - 1]) {\n                  index = indexMax;\n                } else {\n                  var i = 0;\n\n                  while (i < slideCountNew && moved >= slidePositions[i]) {\n                    index = i;\n\n                    if (moved > slidePositions[i] && dist < 0) {\n                      index += 1;\n                    }\n\n                    i++;\n                  }\n                }\n              }\n\n              render(e, dist);\n              events.emit(isTouchEvent(e) ? 'touchEnd' : 'dragEnd', info(e));\n            });\n          } else {\n            if (moveDirectionExpected) {\n              onControlsClick(e, dist > 0 ? -1 : 1);\n            }\n          }\n        }\n      } // reset\n\n\n      if (options.preventScrollOnTouch === 'auto') {\n        preventScroll = false;\n      }\n\n      if (swipeAngle) {\n        moveDirectionExpected = '?';\n      }\n\n      if (autoplay && !animating) {\n        setAutoplayTimer();\n      }\n    } // === RESIZE FUNCTIONS === //\n    // (slidePositions, index, items) => vertical_conentWrapper.height\n\n\n    function updateContentWrapperHeight() {\n      var wp = middleWrapper ? middleWrapper : innerWrapper;\n      wp.style.height = slidePositions[index + items] - slidePositions[index] + 'px';\n    }\n\n    function getPages() {\n      var rough = fixedWidth ? (fixedWidth + gutter) * slideCount / viewport : slideCount / items;\n      return Math.min(Math.ceil(rough), slideCount);\n    }\n    /*\n     * 1. update visible nav items list\n     * 2. add \"hidden\" attributes to previous visible nav items\n     * 3. remove \"hidden\" attrubutes to new visible nav items\n     */\n\n\n    function updateNavVisibility() {\n      if (!nav || navAsThumbnails) {\n        return;\n      }\n\n      if (pages !== pagesCached) {\n        var min = pagesCached,\n            max = pages,\n            fn = showElement;\n\n        if (pagesCached > pages) {\n          min = pages;\n          max = pagesCached;\n          fn = hideElement;\n        }\n\n        while (min < max) {\n          fn(navItems[min]);\n          min++;\n        } // cache pages\n\n\n        pagesCached = pages;\n      }\n    }\n\n    function info(e) {\n      return {\n        container: container,\n        slideItems: slideItems,\n        navContainer: navContainer,\n        navItems: navItems,\n        controlsContainer: controlsContainer,\n        hasControls: hasControls,\n        prevButton: prevButton,\n        nextButton: nextButton,\n        items: items,\n        slideBy: slideBy,\n        cloneCount: cloneCount,\n        slideCount: slideCount,\n        slideCountNew: slideCountNew,\n        index: index,\n        indexCached: indexCached,\n        displayIndex: getCurrentSlide(),\n        navCurrentIndex: navCurrentIndex,\n        navCurrentIndexCached: navCurrentIndexCached,\n        pages: pages,\n        pagesCached: pagesCached,\n        sheet: sheet,\n        isOn: isOn,\n        event: e || {}\n      };\n    }\n\n    return {\n      version: '2.9.3',\n      getInfo: info,\n      events: events,\n      goTo: goTo,\n      play: play,\n      pause: pause,\n      isOn: isOn,\n      updateSliderHeight: updateInnerWrapperHeight,\n      refresh: initSliderTransform,\n      destroy: destroy,\n      rebuild: function () {\n        return tns(extend(options, optionsElements));\n      }\n    };\n  };\n\n  return tns;\n}();\n\n//# sourceURL=webpack:///./node_modules/tiny-slider/dist/tiny-slider.js?");

/***/ })

/******/ });