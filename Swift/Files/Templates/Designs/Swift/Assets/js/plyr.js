/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./Swift/Files/Templates/Designs/Swift/Assets/_src/js/modules/plyr.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./Swift/Files/Templates/Designs/Swift/Assets/_src/js/modules/plyr.js":
/*!****************************************************************************!*\
  !*** ./Swift/Files/Templates/Designs/Swift/Assets/_src/js/modules/plyr.js ***!
  \****************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var plyr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! plyr */ \"./node_modules/plyr/dist/plyr.min.js\");\n/* harmony import */ var plyr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(plyr__WEBPACK_IMPORTED_MODULE_0__);\n\nwindow.Plyr = plyr__WEBPACK_IMPORTED_MODULE_0__;\n\n//# sourceURL=webpack:///./Swift/Files/Templates/Designs/Swift/Assets/_src/js/modules/plyr.js?");

/***/ }),

/***/ "./node_modules/plyr/dist/plyr.min.js":
/*!********************************************!*\
  !*** ./node_modules/plyr/dist/plyr.min.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {\"object\" == typeof navigator && function (e, t) {\n   true ? module.exports = t() : undefined;\n}(this, function () {\n  \"use strict\";\n\n  function e(e, t, i) {\n    return t in e ? Object.defineProperty(e, t, {\n      value: i,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = i, e;\n  }\n  function t(e, t) {\n    for (var i = 0; i < t.length; i++) {\n      var s = t[i];\n      s.enumerable = s.enumerable || !1, s.configurable = !0, \"value\" in s && (s.writable = !0), Object.defineProperty(e, s.key, s);\n    }\n  }\n  function i(e, t, i) {\n    return t in e ? Object.defineProperty(e, t, {\n      value: i,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = i, e;\n  }\n  function s(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var s = Object.getOwnPropertySymbols(e);\n      t && (s = s.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, s);\n    }\n    return i;\n  }\n  function n(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? s(Object(n), !0).forEach(function (t) {\n        i(e, t, n[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : s(Object(n)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));\n      });\n    }\n    return e;\n  }\n  var a = {\n    addCSS: !0,\n    thumbWidth: 15,\n    watch: !0\n  };\n  function l(e, t) {\n    return function () {\n      return Array.from(document.querySelectorAll(t)).includes(this);\n    }.call(e, t);\n  }\n  var o = function (e) {\n      return null != e ? e.constructor : null;\n    },\n    r = function (e, t) {\n      return !!(e && t && e instanceof t);\n    },\n    c = function (e) {\n      return null == e;\n    },\n    h = function (e) {\n      return o(e) === Object;\n    },\n    u = function (e) {\n      return o(e) === String;\n    },\n    d = function (e) {\n      return Array.isArray(e);\n    },\n    m = function (e) {\n      return r(e, NodeList);\n    },\n    p = u,\n    g = d,\n    f = m,\n    b = function (e) {\n      return r(e, Element);\n    },\n    y = function (e) {\n      return r(e, Event);\n    },\n    v = function (e) {\n      return c(e) || (u(e) || d(e) || m(e)) && !e.length || h(e) && !Object.keys(e).length;\n    };\n  function w(e, t) {\n    if (1 > t) {\n      var i = function (e) {\n        var t = \"\".concat(e).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n        return t ? Math.max(0, (t[1] ? t[1].length : 0) - (t[2] ? +t[2] : 0)) : 0;\n      }(t);\n      return parseFloat(e.toFixed(i));\n    }\n    return Math.round(e / t) * t;\n  }\n  var T = function () {\n    function e(t, i) {\n      (function (e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      })(this, e), b(t) ? this.element = t : p(t) && (this.element = document.querySelector(t)), b(this.element) && v(this.element.rangeTouch) && (this.config = n({}, a, {}, i), this.init());\n    }\n    return function (e, i, s) {\n      i && t(e.prototype, i), s && t(e, s);\n    }(e, [{\n      key: \"init\",\n      value: function () {\n        e.enabled && (this.config.addCSS && (this.element.style.userSelect = \"none\", this.element.style.webKitUserSelect = \"none\", this.element.style.touchAction = \"manipulation\"), this.listeners(!0), this.element.rangeTouch = this);\n      }\n    }, {\n      key: \"destroy\",\n      value: function () {\n        e.enabled && (this.config.addCSS && (this.element.style.userSelect = \"\", this.element.style.webKitUserSelect = \"\", this.element.style.touchAction = \"\"), this.listeners(!1), this.element.rangeTouch = null);\n      }\n    }, {\n      key: \"listeners\",\n      value: function (e) {\n        var t = this,\n          i = e ? \"addEventListener\" : \"removeEventListener\";\n        [\"touchstart\", \"touchmove\", \"touchend\"].forEach(function (e) {\n          t.element[i](e, function (e) {\n            return t.set(e);\n          }, !1);\n        });\n      }\n    }, {\n      key: \"get\",\n      value: function (t) {\n        if (!e.enabled || !y(t)) return null;\n        var i,\n          s = t.target,\n          n = t.changedTouches[0],\n          a = parseFloat(s.getAttribute(\"min\")) || 0,\n          l = parseFloat(s.getAttribute(\"max\")) || 100,\n          o = parseFloat(s.getAttribute(\"step\")) || 1,\n          r = s.getBoundingClientRect(),\n          c = 100 / r.width * (this.config.thumbWidth / 2) / 100;\n        return 0 > (i = 100 / r.width * (n.clientX - r.left)) ? i = 0 : 100 < i && (i = 100), 50 > i ? i -= (100 - 2 * i) * c : 50 < i && (i += 2 * (i - 50) * c), a + w(i / 100 * (l - a), o);\n      }\n    }, {\n      key: \"set\",\n      value: function (t) {\n        e.enabled && y(t) && !t.target.disabled && (t.preventDefault(), t.target.value = this.get(t), function (e, t) {\n          if (e && t) {\n            var i = new Event(t, {\n              bubbles: !0\n            });\n            e.dispatchEvent(i);\n          }\n        }(t.target, \"touchend\" === t.type ? \"change\" : \"input\"));\n      }\n    }], [{\n      key: \"setup\",\n      value: function (t) {\n        var i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},\n          s = null;\n        if (v(t) || p(t) ? s = Array.from(document.querySelectorAll(p(t) ? t : 'input[type=\"range\"]')) : b(t) ? s = [t] : f(t) ? s = Array.from(t) : g(t) && (s = t.filter(b)), v(s)) return null;\n        var o = n({}, a, {}, i);\n        if (p(t) && o.watch) {\n          var r = new MutationObserver(function (i) {\n            Array.from(i).forEach(function (i) {\n              Array.from(i.addedNodes).forEach(function (i) {\n                b(i) && l(i, t) && new e(i, o);\n              });\n            });\n          });\n          r.observe(document.body, {\n            childList: !0,\n            subtree: !0\n          });\n        }\n        return s.map(function (t) {\n          return new e(t, i);\n        });\n      }\n    }, {\n      key: \"enabled\",\n      get: function () {\n        return \"ontouchstart\" in document.documentElement;\n      }\n    }]), e;\n  }();\n  const k = e => null != e ? e.constructor : null,\n    C = (e, t) => Boolean(e && t && e instanceof t),\n    A = e => null == e,\n    S = e => k(e) === Object,\n    E = e => k(e) === String,\n    P = e => k(e) === Function,\n    N = e => Array.isArray(e),\n    x = e => C(e, NodeList),\n    M = e => A(e) || (E(e) || N(e) || x(e)) && !e.length || S(e) && !Object.keys(e).length;\n  var I = A,\n    L = S,\n    $ = e => k(e) === Number && !Number.isNaN(e),\n    _ = E,\n    O = e => k(e) === Boolean,\n    j = P,\n    q = N,\n    D = x,\n    H = e => null !== e && \"object\" == typeof e && 1 === e.nodeType && \"object\" == typeof e.style && \"object\" == typeof e.ownerDocument,\n    F = e => C(e, Event),\n    R = e => C(e, KeyboardEvent),\n    V = e => C(e, TextTrack) || !A(e) && E(e.kind),\n    B = e => C(e, Promise) && P(e.then),\n    U = e => {\n      if (C(e, window.URL)) return !0;\n      if (!E(e)) return !1;\n      let t = e;\n      e.startsWith(\"http://\") && e.startsWith(\"https://\") || (t = `http://${e}`);\n      try {\n        return !M(new URL(t).hostname);\n      } catch (e) {\n        return !1;\n      }\n    },\n    W = M;\n  const z = (() => {\n    const e = document.createElement(\"span\"),\n      t = {\n        WebkitTransition: \"webkitTransitionEnd\",\n        MozTransition: \"transitionend\",\n        OTransition: \"oTransitionEnd otransitionend\",\n        transition: \"transitionend\"\n      },\n      i = Object.keys(t).find(t => void 0 !== e.style[t]);\n    return !!_(i) && t[i];\n  })();\n  function K(e, t) {\n    setTimeout(() => {\n      try {\n        e.hidden = !0, e.offsetHeight, e.hidden = !1;\n      } catch (e) {}\n    }, t);\n  }\n  const Y = {\n    isIE: Boolean(window.document.documentMode),\n    isEdge: window.navigator.userAgent.includes(\"Edge\"),\n    isWebkit: \"WebkitAppearance\" in document.documentElement.style && !/Edge/.test(navigator.userAgent),\n    isIPhone: /(iPhone|iPod)/gi.test(navigator.platform),\n    isIos: \"MacIntel\" === navigator.platform && navigator.maxTouchPoints > 1 || /(iPad|iPhone|iPod)/gi.test(navigator.platform)\n  };\n  function Q(e, t) {\n    return t.split(\".\").reduce((e, t) => e && e[t], e);\n  }\n  function X(e = {}, ...t) {\n    if (!t.length) return e;\n    const i = t.shift();\n    return L(i) ? (Object.keys(i).forEach(t => {\n      L(i[t]) ? (Object.keys(e).includes(t) || Object.assign(e, {\n        [t]: {}\n      }), X(e[t], i[t])) : Object.assign(e, {\n        [t]: i[t]\n      });\n    }), X(e, ...t)) : e;\n  }\n  function J(e, t) {\n    const i = e.length ? e : [e];\n    Array.from(i).reverse().forEach((e, i) => {\n      const s = i > 0 ? t.cloneNode(!0) : t,\n        n = e.parentNode,\n        a = e.nextSibling;\n      s.appendChild(e), a ? n.insertBefore(s, a) : n.appendChild(s);\n    });\n  }\n  function G(e, t) {\n    H(e) && !W(t) && Object.entries(t).filter(([, e]) => !I(e)).forEach(([t, i]) => e.setAttribute(t, i));\n  }\n  function Z(e, t, i) {\n    const s = document.createElement(e);\n    return L(t) && G(s, t), _(i) && (s.innerText = i), s;\n  }\n  function ee(e, t, i, s) {\n    H(t) && t.appendChild(Z(e, i, s));\n  }\n  function te(e) {\n    D(e) || q(e) ? Array.from(e).forEach(te) : H(e) && H(e.parentNode) && e.parentNode.removeChild(e);\n  }\n  function ie(e) {\n    if (!H(e)) return;\n    let {\n      length: t\n    } = e.childNodes;\n    for (; t > 0;) e.removeChild(e.lastChild), t -= 1;\n  }\n  function se(e, t) {\n    return H(t) && H(t.parentNode) && H(e) ? (t.parentNode.replaceChild(e, t), e) : null;\n  }\n  function ne(e, t) {\n    if (!_(e) || W(e)) return {};\n    const i = {},\n      s = X({}, t);\n    return e.split(\",\").forEach(e => {\n      const t = e.trim(),\n        n = t.replace(\".\", \"\"),\n        a = t.replace(/[[\\]]/g, \"\").split(\"=\"),\n        [l] = a,\n        o = a.length > 1 ? a[1].replace(/[\"']/g, \"\") : \"\";\n      switch (t.charAt(0)) {\n        case \".\":\n          _(s.class) ? i.class = `${s.class} ${n}` : i.class = n;\n          break;\n        case \"#\":\n          i.id = t.replace(\"#\", \"\");\n          break;\n        case \"[\":\n          i[l] = o;\n      }\n    }), X(s, i);\n  }\n  function ae(e, t) {\n    if (!H(e)) return;\n    let i = t;\n    O(i) || (i = !e.hidden), e.hidden = i;\n  }\n  function le(e, t, i) {\n    if (D(e)) return Array.from(e).map(e => le(e, t, i));\n    if (H(e)) {\n      let s = \"toggle\";\n      return void 0 !== i && (s = i ? \"add\" : \"remove\"), e.classList[s](t), e.classList.contains(t);\n    }\n    return !1;\n  }\n  function oe(e, t) {\n    return H(e) && e.classList.contains(t);\n  }\n  function re(e, t) {\n    const {\n      prototype: i\n    } = Element;\n    return (i.matches || i.webkitMatchesSelector || i.mozMatchesSelector || i.msMatchesSelector || function () {\n      return Array.from(document.querySelectorAll(t)).includes(this);\n    }).call(e, t);\n  }\n  function ce(e) {\n    return this.elements.container.querySelectorAll(e);\n  }\n  function he(e) {\n    return this.elements.container.querySelector(e);\n  }\n  function ue(e = null, t = !1) {\n    H(e) && (e.focus({\n      preventScroll: !0\n    }), t && le(e, this.config.classNames.tabFocus));\n  }\n  const de = {\n      \"audio/ogg\": \"vorbis\",\n      \"audio/wav\": \"1\",\n      \"video/webm\": \"vp8, vorbis\",\n      \"video/mp4\": \"avc1.42E01E, mp4a.40.2\",\n      \"video/ogg\": \"theora\"\n    },\n    me = {\n      audio: \"canPlayType\" in document.createElement(\"audio\"),\n      video: \"canPlayType\" in document.createElement(\"video\"),\n      check(e, t, i) {\n        const s = Y.isIPhone && i && me.playsinline,\n          n = me[e] || \"html5\" !== t;\n        return {\n          api: n,\n          ui: n && me.rangeInput && (\"video\" !== e || !Y.isIPhone || s)\n        };\n      },\n      pip: !(Y.isIPhone || !j(Z(\"video\").webkitSetPresentationMode) && (!document.pictureInPictureEnabled || Z(\"video\").disablePictureInPicture)),\n      airplay: j(window.WebKitPlaybackTargetAvailabilityEvent),\n      playsinline: \"playsInline\" in document.createElement(\"video\"),\n      mime(e) {\n        if (W(e)) return !1;\n        const [t] = e.split(\"/\");\n        let i = e;\n        if (!this.isHTML5 || t !== this.type) return !1;\n        Object.keys(de).includes(i) && (i += `; codecs=\"${de[e]}\"`);\n        try {\n          return Boolean(i && this.media.canPlayType(i).replace(/no/, \"\"));\n        } catch (e) {\n          return !1;\n        }\n      },\n      textTracks: \"textTracks\" in document.createElement(\"video\"),\n      rangeInput: (() => {\n        const e = document.createElement(\"input\");\n        return e.type = \"range\", \"range\" === e.type;\n      })(),\n      touch: \"ontouchstart\" in document.documentElement,\n      transitions: !1 !== z,\n      reducedMotion: \"matchMedia\" in window && window.matchMedia(\"(prefers-reduced-motion)\").matches\n    },\n    pe = (() => {\n      let e = !1;\n      try {\n        const t = Object.defineProperty({}, \"passive\", {\n          get: () => (e = !0, null)\n        });\n        window.addEventListener(\"test\", null, t), window.removeEventListener(\"test\", null, t);\n      } catch (e) {}\n      return e;\n    })();\n  function ge(e, t, i, s = !1, n = !0, a = !1) {\n    if (!e || !(\"addEventListener\" in e) || W(t) || !j(i)) return;\n    const l = t.split(\" \");\n    let o = a;\n    pe && (o = {\n      passive: n,\n      capture: a\n    }), l.forEach(t => {\n      this && this.eventListeners && s && this.eventListeners.push({\n        element: e,\n        type: t,\n        callback: i,\n        options: o\n      }), e[s ? \"addEventListener\" : \"removeEventListener\"](t, i, o);\n    });\n  }\n  function fe(e, t = \"\", i, s = !0, n = !1) {\n    ge.call(this, e, t, i, !0, s, n);\n  }\n  function be(e, t = \"\", i, s = !0, n = !1) {\n    ge.call(this, e, t, i, !1, s, n);\n  }\n  function ye(e, t = \"\", i, s = !0, n = !1) {\n    const a = (...l) => {\n      be(e, t, a, s, n), i.apply(this, l);\n    };\n    ge.call(this, e, t, a, !0, s, n);\n  }\n  function ve(e, t = \"\", i = !1, s = {}) {\n    if (!H(e) || W(t)) return;\n    const n = new CustomEvent(t, {\n      bubbles: i,\n      detail: {\n        ...s,\n        plyr: this\n      }\n    });\n    e.dispatchEvent(n);\n  }\n  function we() {\n    this && this.eventListeners && (this.eventListeners.forEach(e => {\n      const {\n        element: t,\n        type: i,\n        callback: s,\n        options: n\n      } = e;\n      t.removeEventListener(i, s, n);\n    }), this.eventListeners = []);\n  }\n  function Te() {\n    return new Promise(e => this.ready ? setTimeout(e, 0) : fe.call(this, this.elements.container, \"ready\", e)).then(() => {});\n  }\n  function ke(e) {\n    B(e) && e.then(null, () => {});\n  }\n  function Ce(e) {\n    return q(e) ? e.filter((t, i) => e.indexOf(t) === i) : e;\n  }\n  function Ae(e, t) {\n    return q(e) && e.length ? e.reduce((e, i) => Math.abs(i - t) < Math.abs(e - t) ? i : e) : null;\n  }\n  function Se(e) {\n    return !(!window || !window.CSS) && window.CSS.supports(e);\n  }\n  const Ee = [[1, 1], [4, 3], [3, 4], [5, 4], [4, 5], [3, 2], [2, 3], [16, 10], [10, 16], [16, 9], [9, 16], [21, 9], [9, 21], [32, 9], [9, 32]].reduce((e, [t, i]) => ({\n    ...e,\n    [t / i]: [t, i]\n  }), {});\n  function Pe(e) {\n    if (!(q(e) || _(e) && e.includes(\":\"))) return !1;\n    return (q(e) ? e : e.split(\":\")).map(Number).every($);\n  }\n  function Ne(e) {\n    if (!q(e) || !e.every($)) return null;\n    const [t, i] = e,\n      s = (e, t) => 0 === t ? e : s(t, e % t),\n      n = s(t, i);\n    return [t / n, i / n];\n  }\n  function xe(e) {\n    const t = e => Pe(e) ? e.split(\":\").map(Number) : null;\n    let i = t(e);\n    if (null === i && (i = t(this.config.ratio)), null === i && !W(this.embed) && q(this.embed.ratio) && ({\n      ratio: i\n    } = this.embed), null === i && this.isHTML5) {\n      const {\n        videoWidth: e,\n        videoHeight: t\n      } = this.media;\n      i = [e, t];\n    }\n    return Ne(i);\n  }\n  function Me(e) {\n    if (!this.isVideo) return {};\n    const {\n        wrapper: t\n      } = this.elements,\n      i = xe.call(this, e);\n    if (!q(i)) return {};\n    const [s, n] = Ne(i),\n      a = 100 / s * n;\n    if (Se(`aspect-ratio: ${s}/${n}`) ? t.style.aspectRatio = `${s}/${n}` : t.style.paddingBottom = `${a}%`, this.isVimeo && !this.config.vimeo.premium && this.supported.ui) {\n      const e = 100 / this.media.offsetWidth * parseInt(window.getComputedStyle(this.media).paddingBottom, 10),\n        i = (e - a) / (e / 50);\n      this.fullscreen.active ? t.style.paddingBottom = null : this.media.style.transform = `translateY(-${i}%)`;\n    } else this.isHTML5 && t.classList.add(this.config.classNames.videoFixedRatio);\n    return {\n      padding: a,\n      ratio: i\n    };\n  }\n  function Ie(e, t, i = .05) {\n    const s = e / t,\n      n = Ae(Object.keys(Ee), s);\n    return Math.abs(n - s) <= i ? Ee[n] : [e, t];\n  }\n  const Le = {\n    getSources() {\n      if (!this.isHTML5) return [];\n      return Array.from(this.media.querySelectorAll(\"source\")).filter(e => {\n        const t = e.getAttribute(\"type\");\n        return !!W(t) || me.mime.call(this, t);\n      });\n    },\n    getQualityOptions() {\n      return this.config.quality.forced ? this.config.quality.options : Le.getSources.call(this).map(e => Number(e.getAttribute(\"size\"))).filter(Boolean);\n    },\n    setup() {\n      if (!this.isHTML5) return;\n      const e = this;\n      e.options.speed = e.config.speed.options, W(this.config.ratio) || Me.call(e), Object.defineProperty(e.media, \"quality\", {\n        get() {\n          const t = Le.getSources.call(e).find(t => t.getAttribute(\"src\") === e.source);\n          return t && Number(t.getAttribute(\"size\"));\n        },\n        set(t) {\n          if (e.quality !== t) {\n            if (e.config.quality.forced && j(e.config.quality.onChange)) e.config.quality.onChange(t);else {\n              const i = Le.getSources.call(e).find(e => Number(e.getAttribute(\"size\")) === t);\n              if (!i) return;\n              const {\n                currentTime: s,\n                paused: n,\n                preload: a,\n                readyState: l,\n                playbackRate: o\n              } = e.media;\n              e.media.src = i.getAttribute(\"src\"), (\"none\" !== a || l) && (e.once(\"loadedmetadata\", () => {\n                e.speed = o, e.currentTime = s, n || ke(e.play());\n              }), e.media.load());\n            }\n            ve.call(e, e.media, \"qualitychange\", !1, {\n              quality: t\n            });\n          }\n        }\n      });\n    },\n    cancelRequests() {\n      this.isHTML5 && (te(Le.getSources.call(this)), this.media.setAttribute(\"src\", this.config.blankVideo), this.media.load(), this.debug.log(\"Cancelled network requests\"));\n    }\n  };\n  function $e(e, ...t) {\n    return W(e) ? e : e.toString().replace(/{(\\d+)}/g, (e, i) => t[i].toString());\n  }\n  const _e = (e = \"\", t = \"\", i = \"\") => e.replace(new RegExp(t.toString().replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, \"\\\\$1\"), \"g\"), i.toString()),\n    Oe = (e = \"\") => e.toString().replace(/\\w\\S*/g, e => e.charAt(0).toUpperCase() + e.substr(1).toLowerCase());\n  function je(e = \"\") {\n    let t = e.toString();\n    return t = function (e = \"\") {\n      let t = e.toString();\n      return t = _e(t, \"-\", \" \"), t = _e(t, \"_\", \" \"), t = Oe(t), _e(t, \" \", \"\");\n    }(t), t.charAt(0).toLowerCase() + t.slice(1);\n  }\n  function qe(e) {\n    const t = document.createElement(\"div\");\n    return t.appendChild(e), t.innerHTML;\n  }\n  const De = {\n      pip: \"PIP\",\n      airplay: \"AirPlay\",\n      html5: \"HTML5\",\n      vimeo: \"Vimeo\",\n      youtube: \"YouTube\"\n    },\n    He = {\n      get(e = \"\", t = {}) {\n        if (W(e) || W(t)) return \"\";\n        let i = Q(t.i18n, e);\n        if (W(i)) return Object.keys(De).includes(e) ? De[e] : \"\";\n        const s = {\n          \"{seektime}\": t.seekTime,\n          \"{title}\": t.title\n        };\n        return Object.entries(s).forEach(([e, t]) => {\n          i = _e(i, e, t);\n        }), i;\n      }\n    };\n  class Fe {\n    constructor(t) {\n      e(this, \"get\", e => {\n        if (!Fe.supported || !this.enabled) return null;\n        const t = window.localStorage.getItem(this.key);\n        if (W(t)) return null;\n        const i = JSON.parse(t);\n        return _(e) && e.length ? i[e] : i;\n      }), e(this, \"set\", e => {\n        if (!Fe.supported || !this.enabled) return;\n        if (!L(e)) return;\n        let t = this.get();\n        W(t) && (t = {}), X(t, e);\n        try {\n          window.localStorage.setItem(this.key, JSON.stringify(t));\n        } catch (e) {}\n      }), this.enabled = t.config.storage.enabled, this.key = t.config.storage.key;\n    }\n    static get supported() {\n      try {\n        if (!(\"localStorage\" in window)) return !1;\n        const e = \"___test\";\n        return window.localStorage.setItem(e, e), window.localStorage.removeItem(e), !0;\n      } catch (e) {\n        return !1;\n      }\n    }\n  }\n  function Re(e, t = \"text\") {\n    return new Promise((i, s) => {\n      try {\n        const s = new XMLHttpRequest();\n        if (!(\"withCredentials\" in s)) return;\n        s.addEventListener(\"load\", () => {\n          if (\"text\" === t) try {\n            i(JSON.parse(s.responseText));\n          } catch (e) {\n            i(s.responseText);\n          } else i(s.response);\n        }), s.addEventListener(\"error\", () => {\n          throw new Error(s.status);\n        }), s.open(\"GET\", e, !0), s.responseType = t, s.send();\n      } catch (e) {\n        s(e);\n      }\n    });\n  }\n  function Ve(e, t) {\n    if (!_(e)) return;\n    const i = _(t);\n    let s = !1;\n    const n = () => null !== document.getElementById(t),\n      a = (e, t) => {\n        e.innerHTML = t, i && n() || document.body.insertAdjacentElement(\"afterbegin\", e);\n      };\n    if (!i || !n()) {\n      const n = Fe.supported,\n        l = document.createElement(\"div\");\n      if (l.setAttribute(\"hidden\", \"\"), i && l.setAttribute(\"id\", t), n) {\n        const e = window.localStorage.getItem(`cache-${t}`);\n        if (s = null !== e, s) {\n          const t = JSON.parse(e);\n          a(l, t.content);\n        }\n      }\n      Re(e).then(e => {\n        if (!W(e)) {\n          if (n) try {\n            window.localStorage.setItem(`cache-${t}`, JSON.stringify({\n              content: e\n            }));\n          } catch (e) {}\n          a(l, e);\n        }\n      }).catch(() => {});\n    }\n  }\n  const Be = e => Math.trunc(e / 60 / 60 % 60, 10);\n  function Ue(e = 0, t = !1, i = !1) {\n    if (!$(e)) return Ue(void 0, t, i);\n    const s = e => `0${e}`.slice(-2);\n    let n = Be(e);\n    const a = (l = e, Math.trunc(l / 60 % 60, 10));\n    var l;\n    const o = (e => Math.trunc(e % 60, 10))(e);\n    return n = t || n > 0 ? `${n}:` : \"\", `${i && e > 0 ? \"-\" : \"\"}${n}${s(a)}:${s(o)}`;\n  }\n  const We = {\n    getIconUrl() {\n      const e = new URL(this.config.iconUrl, window.location),\n        t = window.location.host ? window.location.host : window.top.location.host,\n        i = e.host !== t || Y.isIE && !window.svg4everybody;\n      return {\n        url: this.config.iconUrl,\n        cors: i\n      };\n    },\n    findElements() {\n      try {\n        return this.elements.controls = he.call(this, this.config.selectors.controls.wrapper), this.elements.buttons = {\n          play: ce.call(this, this.config.selectors.buttons.play),\n          pause: he.call(this, this.config.selectors.buttons.pause),\n          restart: he.call(this, this.config.selectors.buttons.restart),\n          rewind: he.call(this, this.config.selectors.buttons.rewind),\n          fastForward: he.call(this, this.config.selectors.buttons.fastForward),\n          mute: he.call(this, this.config.selectors.buttons.mute),\n          pip: he.call(this, this.config.selectors.buttons.pip),\n          airplay: he.call(this, this.config.selectors.buttons.airplay),\n          settings: he.call(this, this.config.selectors.buttons.settings),\n          captions: he.call(this, this.config.selectors.buttons.captions),\n          fullscreen: he.call(this, this.config.selectors.buttons.fullscreen)\n        }, this.elements.progress = he.call(this, this.config.selectors.progress), this.elements.inputs = {\n          seek: he.call(this, this.config.selectors.inputs.seek),\n          volume: he.call(this, this.config.selectors.inputs.volume)\n        }, this.elements.display = {\n          buffer: he.call(this, this.config.selectors.display.buffer),\n          currentTime: he.call(this, this.config.selectors.display.currentTime),\n          duration: he.call(this, this.config.selectors.display.duration)\n        }, H(this.elements.progress) && (this.elements.display.seekTooltip = this.elements.progress.querySelector(`.${this.config.classNames.tooltip}`)), !0;\n      } catch (e) {\n        return this.debug.warn(\"It looks like there is a problem with your custom controls HTML\", e), this.toggleNativeControls(!0), !1;\n      }\n    },\n    createIcon(e, t) {\n      const i = \"http://www.w3.org/2000/svg\",\n        s = We.getIconUrl.call(this),\n        n = `${s.cors ? \"\" : s.url}#${this.config.iconPrefix}`,\n        a = document.createElementNS(i, \"svg\");\n      G(a, X(t, {\n        \"aria-hidden\": \"true\",\n        focusable: \"false\"\n      }));\n      const l = document.createElementNS(i, \"use\"),\n        o = `${n}-${e}`;\n      return \"href\" in l && l.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", o), l.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", o), a.appendChild(l), a;\n    },\n    createLabel(e, t = {}) {\n      const i = He.get(e, this.config);\n      return Z(\"span\", {\n        ...t,\n        class: [t.class, this.config.classNames.hidden].filter(Boolean).join(\" \")\n      }, i);\n    },\n    createBadge(e) {\n      if (W(e)) return null;\n      const t = Z(\"span\", {\n        class: this.config.classNames.menu.value\n      });\n      return t.appendChild(Z(\"span\", {\n        class: this.config.classNames.menu.badge\n      }, e)), t;\n    },\n    createButton(e, t) {\n      const i = X({}, t);\n      let s = je(e);\n      const n = {\n        element: \"button\",\n        toggle: !1,\n        label: null,\n        icon: null,\n        labelPressed: null,\n        iconPressed: null\n      };\n      switch ([\"element\", \"icon\", \"label\"].forEach(e => {\n        Object.keys(i).includes(e) && (n[e] = i[e], delete i[e]);\n      }), \"button\" !== n.element || Object.keys(i).includes(\"type\") || (i.type = \"button\"), Object.keys(i).includes(\"class\") ? i.class.split(\" \").some(e => e === this.config.classNames.control) || X(i, {\n        class: `${i.class} ${this.config.classNames.control}`\n      }) : i.class = this.config.classNames.control, e) {\n        case \"play\":\n          n.toggle = !0, n.label = \"play\", n.labelPressed = \"pause\", n.icon = \"play\", n.iconPressed = \"pause\";\n          break;\n        case \"mute\":\n          n.toggle = !0, n.label = \"mute\", n.labelPressed = \"unmute\", n.icon = \"volume\", n.iconPressed = \"muted\";\n          break;\n        case \"captions\":\n          n.toggle = !0, n.label = \"enableCaptions\", n.labelPressed = \"disableCaptions\", n.icon = \"captions-off\", n.iconPressed = \"captions-on\";\n          break;\n        case \"fullscreen\":\n          n.toggle = !0, n.label = \"enterFullscreen\", n.labelPressed = \"exitFullscreen\", n.icon = \"enter-fullscreen\", n.iconPressed = \"exit-fullscreen\";\n          break;\n        case \"play-large\":\n          i.class += ` ${this.config.classNames.control}--overlaid`, s = \"play\", n.label = \"play\", n.icon = \"play\";\n          break;\n        default:\n          W(n.label) && (n.label = s), W(n.icon) && (n.icon = e);\n      }\n      const a = Z(n.element);\n      return n.toggle ? (a.appendChild(We.createIcon.call(this, n.iconPressed, {\n        class: \"icon--pressed\"\n      })), a.appendChild(We.createIcon.call(this, n.icon, {\n        class: \"icon--not-pressed\"\n      })), a.appendChild(We.createLabel.call(this, n.labelPressed, {\n        class: \"label--pressed\"\n      })), a.appendChild(We.createLabel.call(this, n.label, {\n        class: \"label--not-pressed\"\n      }))) : (a.appendChild(We.createIcon.call(this, n.icon)), a.appendChild(We.createLabel.call(this, n.label))), X(i, ne(this.config.selectors.buttons[s], i)), G(a, i), \"play\" === s ? (q(this.elements.buttons[s]) || (this.elements.buttons[s] = []), this.elements.buttons[s].push(a)) : this.elements.buttons[s] = a, a;\n    },\n    createRange(e, t) {\n      const i = Z(\"input\", X(ne(this.config.selectors.inputs[e]), {\n        type: \"range\",\n        min: 0,\n        max: 100,\n        step: .01,\n        value: 0,\n        autocomplete: \"off\",\n        role: \"slider\",\n        \"aria-label\": He.get(e, this.config),\n        \"aria-valuemin\": 0,\n        \"aria-valuemax\": 100,\n        \"aria-valuenow\": 0\n      }, t));\n      return this.elements.inputs[e] = i, We.updateRangeFill.call(this, i), T.setup(i), i;\n    },\n    createProgress(e, t) {\n      const i = Z(\"progress\", X(ne(this.config.selectors.display[e]), {\n        min: 0,\n        max: 100,\n        value: 0,\n        role: \"progressbar\",\n        \"aria-hidden\": !0\n      }, t));\n      if (\"volume\" !== e) {\n        i.appendChild(Z(\"span\", null, \"0\"));\n        const t = {\n            played: \"played\",\n            buffer: \"buffered\"\n          }[e],\n          s = t ? He.get(t, this.config) : \"\";\n        i.innerText = `% ${s.toLowerCase()}`;\n      }\n      return this.elements.display[e] = i, i;\n    },\n    createTime(e, t) {\n      const i = ne(this.config.selectors.display[e], t),\n        s = Z(\"div\", X(i, {\n          class: `${i.class ? i.class : \"\"} ${this.config.classNames.display.time} `.trim(),\n          \"aria-label\": He.get(e, this.config)\n        }), \"00:00\");\n      return this.elements.display[e] = s, s;\n    },\n    bindMenuItemShortcuts(e, t) {\n      fe.call(this, e, \"keydown keyup\", i => {\n        if (![32, 38, 39, 40].includes(i.which)) return;\n        if (i.preventDefault(), i.stopPropagation(), \"keydown\" === i.type) return;\n        const s = re(e, '[role=\"menuitemradio\"]');\n        if (!s && [32, 39].includes(i.which)) We.showMenuPanel.call(this, t, !0);else {\n          let t;\n          32 !== i.which && (40 === i.which || s && 39 === i.which ? (t = e.nextElementSibling, H(t) || (t = e.parentNode.firstElementChild)) : (t = e.previousElementSibling, H(t) || (t = e.parentNode.lastElementChild)), ue.call(this, t, !0));\n        }\n      }, !1), fe.call(this, e, \"keyup\", e => {\n        13 === e.which && We.focusFirstMenuItem.call(this, null, !0);\n      });\n    },\n    createMenuItem({\n      value: e,\n      list: t,\n      type: i,\n      title: s,\n      badge: n = null,\n      checked: a = !1\n    }) {\n      const l = ne(this.config.selectors.inputs[i]),\n        o = Z(\"button\", X(l, {\n          type: \"button\",\n          role: \"menuitemradio\",\n          class: `${this.config.classNames.control} ${l.class ? l.class : \"\"}`.trim(),\n          \"aria-checked\": a,\n          value: e\n        })),\n        r = Z(\"span\");\n      r.innerHTML = s, H(n) && r.appendChild(n), o.appendChild(r), Object.defineProperty(o, \"checked\", {\n        enumerable: !0,\n        get: () => \"true\" === o.getAttribute(\"aria-checked\"),\n        set(e) {\n          e && Array.from(o.parentNode.children).filter(e => re(e, '[role=\"menuitemradio\"]')).forEach(e => e.setAttribute(\"aria-checked\", \"false\")), o.setAttribute(\"aria-checked\", e ? \"true\" : \"false\");\n        }\n      }), this.listeners.bind(o, \"click keyup\", t => {\n        if (!R(t) || 32 === t.which) {\n          switch (t.preventDefault(), t.stopPropagation(), o.checked = !0, i) {\n            case \"language\":\n              this.currentTrack = Number(e);\n              break;\n            case \"quality\":\n              this.quality = e;\n              break;\n            case \"speed\":\n              this.speed = parseFloat(e);\n          }\n          We.showMenuPanel.call(this, \"home\", R(t));\n        }\n      }, i, !1), We.bindMenuItemShortcuts.call(this, o, i), t.appendChild(o);\n    },\n    formatTime(e = 0, t = !1) {\n      if (!$(e)) return e;\n      return Ue(e, Be(this.duration) > 0, t);\n    },\n    updateTimeDisplay(e = null, t = 0, i = !1) {\n      H(e) && $(t) && (e.innerText = We.formatTime(t, i));\n    },\n    updateVolume() {\n      this.supported.ui && (H(this.elements.inputs.volume) && We.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume), H(this.elements.buttons.mute) && (this.elements.buttons.mute.pressed = this.muted || 0 === this.volume));\n    },\n    setRange(e, t = 0) {\n      H(e) && (e.value = t, We.updateRangeFill.call(this, e));\n    },\n    updateProgress(e) {\n      if (!this.supported.ui || !F(e)) return;\n      let t = 0;\n      const i = (e, t) => {\n        const i = $(t) ? t : 0,\n          s = H(e) ? e : this.elements.display.buffer;\n        if (H(s)) {\n          s.value = i;\n          const e = s.getElementsByTagName(\"span\")[0];\n          H(e) && (e.childNodes[0].nodeValue = i);\n        }\n      };\n      if (e) switch (e.type) {\n        case \"timeupdate\":\n        case \"seeking\":\n        case \"seeked\":\n          s = this.currentTime, n = this.duration, t = 0 === s || 0 === n || Number.isNaN(s) || Number.isNaN(n) ? 0 : (s / n * 100).toFixed(2), \"timeupdate\" === e.type && We.setRange.call(this, this.elements.inputs.seek, t);\n          break;\n        case \"playing\":\n        case \"progress\":\n          i(this.elements.display.buffer, 100 * this.buffered);\n      }\n      var s, n;\n    },\n    updateRangeFill(e) {\n      const t = F(e) ? e.target : e;\n      if (H(t) && \"range\" === t.getAttribute(\"type\")) {\n        if (re(t, this.config.selectors.inputs.seek)) {\n          t.setAttribute(\"aria-valuenow\", this.currentTime);\n          const e = We.formatTime(this.currentTime),\n            i = We.formatTime(this.duration),\n            s = He.get(\"seekLabel\", this.config);\n          t.setAttribute(\"aria-valuetext\", s.replace(\"{currentTime}\", e).replace(\"{duration}\", i));\n        } else if (re(t, this.config.selectors.inputs.volume)) {\n          const e = 100 * t.value;\n          t.setAttribute(\"aria-valuenow\", e), t.setAttribute(\"aria-valuetext\", `${e.toFixed(1)}%`);\n        } else t.setAttribute(\"aria-valuenow\", t.value);\n        Y.isWebkit && t.style.setProperty(\"--value\", t.value / t.max * 100 + \"%\");\n      }\n    },\n    updateSeekTooltip(e) {\n      if (!this.config.tooltips.seek || !H(this.elements.inputs.seek) || !H(this.elements.display.seekTooltip) || 0 === this.duration) return;\n      const t = `${this.config.classNames.tooltip}--visible`,\n        i = e => le(this.elements.display.seekTooltip, t, e);\n      if (this.touch) return void i(!1);\n      let s = 0;\n      const n = this.elements.progress.getBoundingClientRect();\n      if (F(e)) s = 100 / n.width * (e.pageX - n.left);else {\n        if (!oe(this.elements.display.seekTooltip, t)) return;\n        s = parseFloat(this.elements.display.seekTooltip.style.left, 10);\n      }\n      s < 0 ? s = 0 : s > 100 && (s = 100), We.updateTimeDisplay.call(this, this.elements.display.seekTooltip, this.duration / 100 * s), this.elements.display.seekTooltip.style.left = `${s}%`, F(e) && [\"mouseenter\", \"mouseleave\"].includes(e.type) && i(\"mouseenter\" === e.type);\n    },\n    timeUpdate(e) {\n      const t = !H(this.elements.display.duration) && this.config.invertTime;\n      We.updateTimeDisplay.call(this, this.elements.display.currentTime, t ? this.duration - this.currentTime : this.currentTime, t), e && \"timeupdate\" === e.type && this.media.seeking || We.updateProgress.call(this, e);\n    },\n    durationUpdate() {\n      if (!this.supported.ui || !this.config.invertTime && this.currentTime) return;\n      if (this.duration >= 2 ** 32) return ae(this.elements.display.currentTime, !0), void ae(this.elements.progress, !0);\n      H(this.elements.inputs.seek) && this.elements.inputs.seek.setAttribute(\"aria-valuemax\", this.duration);\n      const e = H(this.elements.display.duration);\n      !e && this.config.displayDuration && this.paused && We.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration), e && We.updateTimeDisplay.call(this, this.elements.display.duration, this.duration), We.updateSeekTooltip.call(this);\n    },\n    toggleMenuButton(e, t) {\n      ae(this.elements.settings.buttons[e], !t);\n    },\n    updateSetting(e, t, i) {\n      const s = this.elements.settings.panels[e];\n      let n = null,\n        a = t;\n      if (\"captions\" === e) n = this.currentTrack;else {\n        if (n = W(i) ? this[e] : i, W(n) && (n = this.config[e].default), !W(this.options[e]) && !this.options[e].includes(n)) return void this.debug.warn(`Unsupported value of '${n}' for ${e}`);\n        if (!this.config[e].options.includes(n)) return void this.debug.warn(`Disabled value of '${n}' for ${e}`);\n      }\n      if (H(a) || (a = s && s.querySelector('[role=\"menu\"]')), !H(a)) return;\n      this.elements.settings.buttons[e].querySelector(`.${this.config.classNames.menu.value}`).innerHTML = We.getLabel.call(this, e, n);\n      const l = a && a.querySelector(`[value=\"${n}\"]`);\n      H(l) && (l.checked = !0);\n    },\n    getLabel(e, t) {\n      switch (e) {\n        case \"speed\":\n          return 1 === t ? He.get(\"normal\", this.config) : `${t}&times;`;\n        case \"quality\":\n          if ($(t)) {\n            const e = He.get(`qualityLabel.${t}`, this.config);\n            return e.length ? e : `${t}p`;\n          }\n          return Oe(t);\n        case \"captions\":\n          return Ye.getLabel.call(this);\n        default:\n          return null;\n      }\n    },\n    setQualityMenu(e) {\n      if (!H(this.elements.settings.panels.quality)) return;\n      const t = \"quality\",\n        i = this.elements.settings.panels.quality.querySelector('[role=\"menu\"]');\n      q(e) && (this.options.quality = Ce(e).filter(e => this.config.quality.options.includes(e)));\n      const s = !W(this.options.quality) && this.options.quality.length > 1;\n      if (We.toggleMenuButton.call(this, t, s), ie(i), We.checkMenu.call(this), !s) return;\n      const n = e => {\n        const t = He.get(`qualityBadge.${e}`, this.config);\n        return t.length ? We.createBadge.call(this, t) : null;\n      };\n      this.options.quality.sort((e, t) => {\n        const i = this.config.quality.options;\n        return i.indexOf(e) > i.indexOf(t) ? 1 : -1;\n      }).forEach(e => {\n        We.createMenuItem.call(this, {\n          value: e,\n          list: i,\n          type: t,\n          title: We.getLabel.call(this, \"quality\", e),\n          badge: n(e)\n        });\n      }), We.updateSetting.call(this, t, i);\n    },\n    setCaptionsMenu() {\n      if (!H(this.elements.settings.panels.captions)) return;\n      const e = \"captions\",\n        t = this.elements.settings.panels.captions.querySelector('[role=\"menu\"]'),\n        i = Ye.getTracks.call(this),\n        s = Boolean(i.length);\n      if (We.toggleMenuButton.call(this, e, s), ie(t), We.checkMenu.call(this), !s) return;\n      const n = i.map((e, i) => ({\n        value: i,\n        checked: this.captions.toggled && this.currentTrack === i,\n        title: Ye.getLabel.call(this, e),\n        badge: e.language && We.createBadge.call(this, e.language.toUpperCase()),\n        list: t,\n        type: \"language\"\n      }));\n      n.unshift({\n        value: -1,\n        checked: !this.captions.toggled,\n        title: He.get(\"disabled\", this.config),\n        list: t,\n        type: \"language\"\n      }), n.forEach(We.createMenuItem.bind(this)), We.updateSetting.call(this, e, t);\n    },\n    setSpeedMenu() {\n      if (!H(this.elements.settings.panels.speed)) return;\n      const e = \"speed\",\n        t = this.elements.settings.panels.speed.querySelector('[role=\"menu\"]');\n      this.options.speed = this.options.speed.filter(e => e >= this.minimumSpeed && e <= this.maximumSpeed);\n      const i = !W(this.options.speed) && this.options.speed.length > 1;\n      We.toggleMenuButton.call(this, e, i), ie(t), We.checkMenu.call(this), i && (this.options.speed.forEach(i => {\n        We.createMenuItem.call(this, {\n          value: i,\n          list: t,\n          type: e,\n          title: We.getLabel.call(this, \"speed\", i)\n        });\n      }), We.updateSetting.call(this, e, t));\n    },\n    checkMenu() {\n      const {\n          buttons: e\n        } = this.elements.settings,\n        t = !W(e) && Object.values(e).some(e => !e.hidden);\n      ae(this.elements.settings.menu, !t);\n    },\n    focusFirstMenuItem(e, t = !1) {\n      if (this.elements.settings.popup.hidden) return;\n      let i = e;\n      H(i) || (i = Object.values(this.elements.settings.panels).find(e => !e.hidden));\n      const s = i.querySelector('[role^=\"menuitem\"]');\n      ue.call(this, s, t);\n    },\n    toggleMenu(e) {\n      const {\n          popup: t\n        } = this.elements.settings,\n        i = this.elements.buttons.settings;\n      if (!H(t) || !H(i)) return;\n      const {\n        hidden: s\n      } = t;\n      let n = s;\n      if (O(e)) n = e;else if (R(e) && 27 === e.which) n = !1;else if (F(e)) {\n        const s = j(e.composedPath) ? e.composedPath()[0] : e.target,\n          a = t.contains(s);\n        if (a || !a && e.target !== i && n) return;\n      }\n      i.setAttribute(\"aria-expanded\", n), ae(t, !n), le(this.elements.container, this.config.classNames.menu.open, n), n && R(e) ? We.focusFirstMenuItem.call(this, null, !0) : n || s || ue.call(this, i, R(e));\n    },\n    getMenuSize(e) {\n      const t = e.cloneNode(!0);\n      t.style.position = \"absolute\", t.style.opacity = 0, t.removeAttribute(\"hidden\"), e.parentNode.appendChild(t);\n      const i = t.scrollWidth,\n        s = t.scrollHeight;\n      return te(t), {\n        width: i,\n        height: s\n      };\n    },\n    showMenuPanel(e = \"\", t = !1) {\n      const i = this.elements.container.querySelector(`#plyr-settings-${this.id}-${e}`);\n      if (!H(i)) return;\n      const s = i.parentNode,\n        n = Array.from(s.children).find(e => !e.hidden);\n      if (me.transitions && !me.reducedMotion) {\n        s.style.width = `${n.scrollWidth}px`, s.style.height = `${n.scrollHeight}px`;\n        const e = We.getMenuSize.call(this, i),\n          t = e => {\n            e.target === s && [\"width\", \"height\"].includes(e.propertyName) && (s.style.width = \"\", s.style.height = \"\", be.call(this, s, z, t));\n          };\n        fe.call(this, s, z, t), s.style.width = `${e.width}px`, s.style.height = `${e.height}px`;\n      }\n      ae(n, !0), ae(i, !1), We.focusFirstMenuItem.call(this, i, t);\n    },\n    setDownloadUrl() {\n      const e = this.elements.buttons.download;\n      H(e) && e.setAttribute(\"href\", this.download);\n    },\n    create(e) {\n      const {\n        bindMenuItemShortcuts: t,\n        createButton: i,\n        createProgress: s,\n        createRange: n,\n        createTime: a,\n        setQualityMenu: l,\n        setSpeedMenu: o,\n        showMenuPanel: r\n      } = We;\n      this.elements.controls = null, q(this.config.controls) && this.config.controls.includes(\"play-large\") && this.elements.container.appendChild(i.call(this, \"play-large\"));\n      const c = Z(\"div\", ne(this.config.selectors.controls.wrapper));\n      this.elements.controls = c;\n      const h = {\n        class: \"plyr__controls__item\"\n      };\n      return Ce(q(this.config.controls) ? this.config.controls : []).forEach(l => {\n        if (\"restart\" === l && c.appendChild(i.call(this, \"restart\", h)), \"rewind\" === l && c.appendChild(i.call(this, \"rewind\", h)), \"play\" === l && c.appendChild(i.call(this, \"play\", h)), \"fast-forward\" === l && c.appendChild(i.call(this, \"fast-forward\", h)), \"progress\" === l) {\n          const t = Z(\"div\", {\n              class: `${h.class} plyr__progress__container`\n            }),\n            i = Z(\"div\", ne(this.config.selectors.progress));\n          if (i.appendChild(n.call(this, \"seek\", {\n            id: `plyr-seek-${e.id}`\n          })), i.appendChild(s.call(this, \"buffer\")), this.config.tooltips.seek) {\n            const e = Z(\"span\", {\n              class: this.config.classNames.tooltip\n            }, \"00:00\");\n            i.appendChild(e), this.elements.display.seekTooltip = e;\n          }\n          this.elements.progress = i, t.appendChild(this.elements.progress), c.appendChild(t);\n        }\n        if (\"current-time\" === l && c.appendChild(a.call(this, \"currentTime\", h)), \"duration\" === l && c.appendChild(a.call(this, \"duration\", h)), \"mute\" === l || \"volume\" === l) {\n          let {\n            volume: t\n          } = this.elements;\n          if (H(t) && c.contains(t) || (t = Z(\"div\", X({}, h, {\n            class: `${h.class} plyr__volume`.trim()\n          })), this.elements.volume = t, c.appendChild(t)), \"mute\" === l && t.appendChild(i.call(this, \"mute\")), \"volume\" === l && !Y.isIos) {\n            const i = {\n              max: 1,\n              step: .05,\n              value: this.config.volume\n            };\n            t.appendChild(n.call(this, \"volume\", X(i, {\n              id: `plyr-volume-${e.id}`\n            })));\n          }\n        }\n        if (\"captions\" === l && c.appendChild(i.call(this, \"captions\", h)), \"settings\" === l && !W(this.config.settings)) {\n          const s = Z(\"div\", X({}, h, {\n            class: `${h.class} plyr__menu`.trim(),\n            hidden: \"\"\n          }));\n          s.appendChild(i.call(this, \"settings\", {\n            \"aria-haspopup\": !0,\n            \"aria-controls\": `plyr-settings-${e.id}`,\n            \"aria-expanded\": !1\n          }));\n          const n = Z(\"div\", {\n              class: \"plyr__menu__container\",\n              id: `plyr-settings-${e.id}`,\n              hidden: \"\"\n            }),\n            a = Z(\"div\"),\n            l = Z(\"div\", {\n              id: `plyr-settings-${e.id}-home`\n            }),\n            o = Z(\"div\", {\n              role: \"menu\"\n            });\n          l.appendChild(o), a.appendChild(l), this.elements.settings.panels.home = l, this.config.settings.forEach(i => {\n            const s = Z(\"button\", X(ne(this.config.selectors.buttons.settings), {\n              type: \"button\",\n              class: `${this.config.classNames.control} ${this.config.classNames.control}--forward`,\n              role: \"menuitem\",\n              \"aria-haspopup\": !0,\n              hidden: \"\"\n            }));\n            t.call(this, s, i), fe.call(this, s, \"click\", () => {\n              r.call(this, i, !1);\n            });\n            const n = Z(\"span\", null, He.get(i, this.config)),\n              l = Z(\"span\", {\n                class: this.config.classNames.menu.value\n              });\n            l.innerHTML = e[i], n.appendChild(l), s.appendChild(n), o.appendChild(s);\n            const c = Z(\"div\", {\n                id: `plyr-settings-${e.id}-${i}`,\n                hidden: \"\"\n              }),\n              h = Z(\"button\", {\n                type: \"button\",\n                class: `${this.config.classNames.control} ${this.config.classNames.control}--back`\n              });\n            h.appendChild(Z(\"span\", {\n              \"aria-hidden\": !0\n            }, He.get(i, this.config))), h.appendChild(Z(\"span\", {\n              class: this.config.classNames.hidden\n            }, He.get(\"menuBack\", this.config))), fe.call(this, c, \"keydown\", e => {\n              37 === e.which && (e.preventDefault(), e.stopPropagation(), r.call(this, \"home\", !0));\n            }, !1), fe.call(this, h, \"click\", () => {\n              r.call(this, \"home\", !1);\n            }), c.appendChild(h), c.appendChild(Z(\"div\", {\n              role: \"menu\"\n            })), a.appendChild(c), this.elements.settings.buttons[i] = s, this.elements.settings.panels[i] = c;\n          }), n.appendChild(a), s.appendChild(n), c.appendChild(s), this.elements.settings.popup = n, this.elements.settings.menu = s;\n        }\n        if (\"pip\" === l && me.pip && c.appendChild(i.call(this, \"pip\", h)), \"airplay\" === l && me.airplay && c.appendChild(i.call(this, \"airplay\", h)), \"download\" === l) {\n          const e = X({}, h, {\n            element: \"a\",\n            href: this.download,\n            target: \"_blank\"\n          });\n          this.isHTML5 && (e.download = \"\");\n          const {\n            download: t\n          } = this.config.urls;\n          !U(t) && this.isEmbed && X(e, {\n            icon: `logo-${this.provider}`,\n            label: this.provider\n          }), c.appendChild(i.call(this, \"download\", e));\n        }\n        \"fullscreen\" === l && c.appendChild(i.call(this, \"fullscreen\", h));\n      }), this.isHTML5 && l.call(this, Le.getQualityOptions.call(this)), o.call(this), c;\n    },\n    inject() {\n      if (this.config.loadSprite) {\n        const e = We.getIconUrl.call(this);\n        e.cors && Ve(e.url, \"sprite-plyr\");\n      }\n      this.id = Math.floor(1e4 * Math.random());\n      let e = null;\n      this.elements.controls = null;\n      const t = {\n        id: this.id,\n        seektime: this.config.seekTime,\n        title: this.config.title\n      };\n      let i = !0;\n      j(this.config.controls) && (this.config.controls = this.config.controls.call(this, t)), this.config.controls || (this.config.controls = []), H(this.config.controls) || _(this.config.controls) ? e = this.config.controls : (e = We.create.call(this, {\n        id: this.id,\n        seektime: this.config.seekTime,\n        speed: this.speed,\n        quality: this.quality,\n        captions: Ye.getLabel.call(this)\n      }), i = !1);\n      let s;\n      i && _(this.config.controls) && (e = (e => {\n        let i = e;\n        return Object.entries(t).forEach(([e, t]) => {\n          i = _e(i, `{${e}}`, t);\n        }), i;\n      })(e)), _(this.config.selectors.controls.container) && (s = document.querySelector(this.config.selectors.controls.container)), H(s) || (s = this.elements.container);\n      if (s[H(e) ? \"insertAdjacentElement\" : \"insertAdjacentHTML\"](\"afterbegin\", e), H(this.elements.controls) || We.findElements.call(this), !W(this.elements.buttons)) {\n        const e = e => {\n          const t = this.config.classNames.controlPressed;\n          Object.defineProperty(e, \"pressed\", {\n            enumerable: !0,\n            get: () => oe(e, t),\n            set(i = !1) {\n              le(e, t, i);\n            }\n          });\n        };\n        Object.values(this.elements.buttons).filter(Boolean).forEach(t => {\n          q(t) || D(t) ? Array.from(t).filter(Boolean).forEach(e) : e(t);\n        });\n      }\n      if (Y.isEdge && K(s), this.config.tooltips.controls) {\n        const {\n            classNames: e,\n            selectors: t\n          } = this.config,\n          i = `${t.controls.wrapper} ${t.labels} .${e.hidden}`,\n          s = ce.call(this, i);\n        Array.from(s).forEach(e => {\n          le(e, this.config.classNames.hidden, !1), le(e, this.config.classNames.tooltip, !0);\n        });\n      }\n    }\n  };\n  function ze(e, t = !0) {\n    let i = e;\n    if (t) {\n      const e = document.createElement(\"a\");\n      e.href = i, i = e.href;\n    }\n    try {\n      return new URL(i);\n    } catch (e) {\n      return null;\n    }\n  }\n  function Ke(e) {\n    const t = new URLSearchParams();\n    return L(e) && Object.entries(e).forEach(([e, i]) => {\n      t.set(e, i);\n    }), t;\n  }\n  const Ye = {\n      setup() {\n        if (!this.supported.ui) return;\n        if (!this.isVideo || this.isYouTube || this.isHTML5 && !me.textTracks) return void (q(this.config.controls) && this.config.controls.includes(\"settings\") && this.config.settings.includes(\"captions\") && We.setCaptionsMenu.call(this));\n        var e, t;\n        if (H(this.elements.captions) || (this.elements.captions = Z(\"div\", ne(this.config.selectors.captions)), e = this.elements.captions, t = this.elements.wrapper, H(e) && H(t) && t.parentNode.insertBefore(e, t.nextSibling)), Y.isIE && window.URL) {\n          const e = this.media.querySelectorAll(\"track\");\n          Array.from(e).forEach(e => {\n            const t = e.getAttribute(\"src\"),\n              i = ze(t);\n            null !== i && i.hostname !== window.location.href.hostname && [\"http:\", \"https:\"].includes(i.protocol) && Re(t, \"blob\").then(t => {\n              e.setAttribute(\"src\", window.URL.createObjectURL(t));\n            }).catch(() => {\n              te(e);\n            });\n          });\n        }\n        const i = Ce((navigator.languages || [navigator.language || navigator.userLanguage || \"en\"]).map(e => e.split(\"-\")[0]));\n        let s = (this.storage.get(\"language\") || this.config.captions.language || \"auto\").toLowerCase();\n        \"auto\" === s && ([s] = i);\n        let n = this.storage.get(\"captions\");\n        if (O(n) || ({\n          active: n\n        } = this.config.captions), Object.assign(this.captions, {\n          toggled: !1,\n          active: n,\n          language: s,\n          languages: i\n        }), this.isHTML5) {\n          const e = this.config.captions.update ? \"addtrack removetrack\" : \"removetrack\";\n          fe.call(this, this.media.textTracks, e, Ye.update.bind(this));\n        }\n        setTimeout(Ye.update.bind(this), 0);\n      },\n      update() {\n        const e = Ye.getTracks.call(this, !0),\n          {\n            active: t,\n            language: i,\n            meta: s,\n            currentTrackNode: n\n          } = this.captions,\n          a = Boolean(e.find(e => e.language === i));\n        this.isHTML5 && this.isVideo && e.filter(e => !s.get(e)).forEach(e => {\n          this.debug.log(\"Track added\", e), s.set(e, {\n            default: \"showing\" === e.mode\n          }), \"showing\" === e.mode && (e.mode = \"hidden\"), fe.call(this, e, \"cuechange\", () => Ye.updateCues.call(this));\n        }), (a && this.language !== i || !e.includes(n)) && (Ye.setLanguage.call(this, i), Ye.toggle.call(this, t && a)), this.elements && le(this.elements.container, this.config.classNames.captions.enabled, !W(e)), q(this.config.controls) && this.config.controls.includes(\"settings\") && this.config.settings.includes(\"captions\") && We.setCaptionsMenu.call(this);\n      },\n      toggle(e, t = !0) {\n        if (!this.supported.ui) return;\n        const {\n            toggled: i\n          } = this.captions,\n          s = this.config.classNames.captions.active,\n          n = I(e) ? !i : e;\n        if (n !== i) {\n          if (t || (this.captions.active = n, this.storage.set({\n            captions: n\n          })), !this.language && n && !t) {\n            const e = Ye.getTracks.call(this),\n              t = Ye.findTrack.call(this, [this.captions.language, ...this.captions.languages], !0);\n            return this.captions.language = t.language, void Ye.set.call(this, e.indexOf(t));\n          }\n          this.elements.buttons.captions && (this.elements.buttons.captions.pressed = n), le(this.elements.container, s, n), this.captions.toggled = n, We.updateSetting.call(this, \"captions\"), ve.call(this, this.media, n ? \"captionsenabled\" : \"captionsdisabled\");\n        }\n        setTimeout(() => {\n          n && this.captions.toggled && (this.captions.currentTrackNode.mode = \"hidden\");\n        });\n      },\n      set(e, t = !0) {\n        const i = Ye.getTracks.call(this);\n        if (-1 !== e) {\n          if ($(e)) {\n            if (e in i) {\n              if (this.captions.currentTrack !== e) {\n                this.captions.currentTrack = e;\n                const s = i[e],\n                  {\n                    language: n\n                  } = s || {};\n                this.captions.currentTrackNode = s, We.updateSetting.call(this, \"captions\"), t || (this.captions.language = n, this.storage.set({\n                  language: n\n                })), this.isVimeo && this.embed.enableTextTrack(n), ve.call(this, this.media, \"languagechange\");\n              }\n              Ye.toggle.call(this, !0, t), this.isHTML5 && this.isVideo && Ye.updateCues.call(this);\n            } else this.debug.warn(\"Track not found\", e);\n          } else this.debug.warn(\"Invalid caption argument\", e);\n        } else Ye.toggle.call(this, !1, t);\n      },\n      setLanguage(e, t = !0) {\n        if (!_(e)) return void this.debug.warn(\"Invalid language argument\", e);\n        const i = e.toLowerCase();\n        this.captions.language = i;\n        const s = Ye.getTracks.call(this),\n          n = Ye.findTrack.call(this, [i]);\n        Ye.set.call(this, s.indexOf(n), t);\n      },\n      getTracks(e = !1) {\n        return Array.from((this.media || {}).textTracks || []).filter(t => !this.isHTML5 || e || this.captions.meta.has(t)).filter(e => [\"captions\", \"subtitles\"].includes(e.kind));\n      },\n      findTrack(e, t = !1) {\n        const i = Ye.getTracks.call(this),\n          s = e => Number((this.captions.meta.get(e) || {}).default),\n          n = Array.from(i).sort((e, t) => s(t) - s(e));\n        let a;\n        return e.every(e => (a = n.find(t => t.language === e), !a)), a || (t ? n[0] : void 0);\n      },\n      getCurrentTrack() {\n        return Ye.getTracks.call(this)[this.currentTrack];\n      },\n      getLabel(e) {\n        let t = e;\n        return !V(t) && me.textTracks && this.captions.toggled && (t = Ye.getCurrentTrack.call(this)), V(t) ? W(t.label) ? W(t.language) ? He.get(\"enabled\", this.config) : e.language.toUpperCase() : t.label : He.get(\"disabled\", this.config);\n      },\n      updateCues(e) {\n        if (!this.supported.ui) return;\n        if (!H(this.elements.captions)) return void this.debug.warn(\"No captions element to render to\");\n        if (!I(e) && !Array.isArray(e)) return void this.debug.warn(\"updateCues: Invalid input\", e);\n        let t = e;\n        if (!t) {\n          const e = Ye.getCurrentTrack.call(this);\n          t = Array.from((e || {}).activeCues || []).map(e => e.getCueAsHTML()).map(qe);\n        }\n        const i = t.map(e => e.trim()).join(\"\\n\");\n        if (i !== this.elements.captions.innerHTML) {\n          ie(this.elements.captions);\n          const e = Z(\"span\", ne(this.config.selectors.caption));\n          e.innerHTML = i, this.elements.captions.appendChild(e), ve.call(this, this.media, \"cuechange\");\n        }\n      }\n    },\n    Qe = {\n      enabled: !0,\n      title: \"\",\n      debug: !1,\n      autoplay: !1,\n      autopause: !0,\n      playsinline: !0,\n      seekTime: 10,\n      volume: 1,\n      muted: !1,\n      duration: null,\n      displayDuration: !0,\n      invertTime: !0,\n      toggleInvert: !0,\n      ratio: null,\n      clickToPlay: !0,\n      hideControls: !0,\n      resetOnEnd: !1,\n      disableContextMenu: !0,\n      loadSprite: !0,\n      iconPrefix: \"plyr\",\n      iconUrl: \"https://cdn.plyr.io/3.6.12/plyr.svg\",\n      blankVideo: \"https://cdn.plyr.io/static/blank.mp4\",\n      quality: {\n        default: 576,\n        options: [4320, 2880, 2160, 1440, 1080, 720, 576, 480, 360, 240],\n        forced: !1,\n        onChange: null\n      },\n      loop: {\n        active: !1\n      },\n      speed: {\n        selected: 1,\n        options: [.5, .75, 1, 1.25, 1.5, 1.75, 2, 4]\n      },\n      keyboard: {\n        focused: !0,\n        global: !1\n      },\n      tooltips: {\n        controls: !1,\n        seek: !0\n      },\n      captions: {\n        active: !1,\n        language: \"auto\",\n        update: !1\n      },\n      fullscreen: {\n        enabled: !0,\n        fallback: !0,\n        iosNative: !1\n      },\n      storage: {\n        enabled: !0,\n        key: \"plyr\"\n      },\n      controls: [\"play-large\", \"play\", \"progress\", \"current-time\", \"mute\", \"volume\", \"captions\", \"settings\", \"pip\", \"airplay\", \"fullscreen\"],\n      settings: [\"captions\", \"quality\", \"speed\"],\n      i18n: {\n        restart: \"Restart\",\n        rewind: \"Rewind {seektime}s\",\n        play: \"Play\",\n        pause: \"Pause\",\n        fastForward: \"Forward {seektime}s\",\n        seek: \"Seek\",\n        seekLabel: \"{currentTime} of {duration}\",\n        played: \"Played\",\n        buffered: \"Buffered\",\n        currentTime: \"Current time\",\n        duration: \"Duration\",\n        volume: \"Volume\",\n        mute: \"Mute\",\n        unmute: \"Unmute\",\n        enableCaptions: \"Enable captions\",\n        disableCaptions: \"Disable captions\",\n        download: \"Download\",\n        enterFullscreen: \"Enter fullscreen\",\n        exitFullscreen: \"Exit fullscreen\",\n        frameTitle: \"Player for {title}\",\n        captions: \"Captions\",\n        settings: \"Settings\",\n        pip: \"PIP\",\n        menuBack: \"Go back to previous menu\",\n        speed: \"Speed\",\n        normal: \"Normal\",\n        quality: \"Quality\",\n        loop: \"Loop\",\n        start: \"Start\",\n        end: \"End\",\n        all: \"All\",\n        reset: \"Reset\",\n        disabled: \"Disabled\",\n        enabled: \"Enabled\",\n        advertisement: \"Ad\",\n        qualityBadge: {\n          2160: \"4K\",\n          1440: \"HD\",\n          1080: \"HD\",\n          720: \"HD\",\n          576: \"SD\",\n          480: \"SD\"\n        }\n      },\n      urls: {\n        download: null,\n        vimeo: {\n          sdk: \"https://player.vimeo.com/api/player.js\",\n          iframe: \"https://player.vimeo.com/video/{0}?{1}\",\n          api: \"https://vimeo.com/api/oembed.json?url={0}\"\n        },\n        youtube: {\n          sdk: \"https://www.youtube.com/iframe_api\",\n          api: \"https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}\"\n        },\n        googleIMA: {\n          sdk: \"https://imasdk.googleapis.com/js/sdkloader/ima3.js\"\n        }\n      },\n      listeners: {\n        seek: null,\n        play: null,\n        pause: null,\n        restart: null,\n        rewind: null,\n        fastForward: null,\n        mute: null,\n        volume: null,\n        captions: null,\n        download: null,\n        fullscreen: null,\n        pip: null,\n        airplay: null,\n        speed: null,\n        quality: null,\n        loop: null,\n        language: null\n      },\n      events: [\"ended\", \"progress\", \"stalled\", \"playing\", \"waiting\", \"canplay\", \"canplaythrough\", \"loadstart\", \"loadeddata\", \"loadedmetadata\", \"timeupdate\", \"volumechange\", \"play\", \"pause\", \"error\", \"seeking\", \"seeked\", \"emptied\", \"ratechange\", \"cuechange\", \"download\", \"enterfullscreen\", \"exitfullscreen\", \"captionsenabled\", \"captionsdisabled\", \"languagechange\", \"controlshidden\", \"controlsshown\", \"ready\", \"statechange\", \"qualitychange\", \"adsloaded\", \"adscontentpause\", \"adscontentresume\", \"adstarted\", \"adsmidpoint\", \"adscomplete\", \"adsallcomplete\", \"adsimpression\", \"adsclick\"],\n      selectors: {\n        editable: \"input, textarea, select, [contenteditable]\",\n        container: \".plyr\",\n        controls: {\n          container: null,\n          wrapper: \".plyr__controls\"\n        },\n        labels: \"[data-plyr]\",\n        buttons: {\n          play: '[data-plyr=\"play\"]',\n          pause: '[data-plyr=\"pause\"]',\n          restart: '[data-plyr=\"restart\"]',\n          rewind: '[data-plyr=\"rewind\"]',\n          fastForward: '[data-plyr=\"fast-forward\"]',\n          mute: '[data-plyr=\"mute\"]',\n          captions: '[data-plyr=\"captions\"]',\n          download: '[data-plyr=\"download\"]',\n          fullscreen: '[data-plyr=\"fullscreen\"]',\n          pip: '[data-plyr=\"pip\"]',\n          airplay: '[data-plyr=\"airplay\"]',\n          settings: '[data-plyr=\"settings\"]',\n          loop: '[data-plyr=\"loop\"]'\n        },\n        inputs: {\n          seek: '[data-plyr=\"seek\"]',\n          volume: '[data-plyr=\"volume\"]',\n          speed: '[data-plyr=\"speed\"]',\n          language: '[data-plyr=\"language\"]',\n          quality: '[data-plyr=\"quality\"]'\n        },\n        display: {\n          currentTime: \".plyr__time--current\",\n          duration: \".plyr__time--duration\",\n          buffer: \".plyr__progress__buffer\",\n          loop: \".plyr__progress__loop\",\n          volume: \".plyr__volume--display\"\n        },\n        progress: \".plyr__progress\",\n        captions: \".plyr__captions\",\n        caption: \".plyr__caption\"\n      },\n      classNames: {\n        type: \"plyr--{0}\",\n        provider: \"plyr--{0}\",\n        video: \"plyr__video-wrapper\",\n        embed: \"plyr__video-embed\",\n        videoFixedRatio: \"plyr__video-wrapper--fixed-ratio\",\n        embedContainer: \"plyr__video-embed__container\",\n        poster: \"plyr__poster\",\n        posterEnabled: \"plyr__poster-enabled\",\n        ads: \"plyr__ads\",\n        control: \"plyr__control\",\n        controlPressed: \"plyr__control--pressed\",\n        playing: \"plyr--playing\",\n        paused: \"plyr--paused\",\n        stopped: \"plyr--stopped\",\n        loading: \"plyr--loading\",\n        hover: \"plyr--hover\",\n        tooltip: \"plyr__tooltip\",\n        cues: \"plyr__cues\",\n        hidden: \"plyr__sr-only\",\n        hideControls: \"plyr--hide-controls\",\n        isIos: \"plyr--is-ios\",\n        isTouch: \"plyr--is-touch\",\n        uiSupported: \"plyr--full-ui\",\n        noTransition: \"plyr--no-transition\",\n        display: {\n          time: \"plyr__time\"\n        },\n        menu: {\n          value: \"plyr__menu__value\",\n          badge: \"plyr__badge\",\n          open: \"plyr--menu-open\"\n        },\n        captions: {\n          enabled: \"plyr--captions-enabled\",\n          active: \"plyr--captions-active\"\n        },\n        fullscreen: {\n          enabled: \"plyr--fullscreen-enabled\",\n          fallback: \"plyr--fullscreen-fallback\"\n        },\n        pip: {\n          supported: \"plyr--pip-supported\",\n          active: \"plyr--pip-active\"\n        },\n        airplay: {\n          supported: \"plyr--airplay-supported\",\n          active: \"plyr--airplay-active\"\n        },\n        tabFocus: \"plyr__tab-focus\",\n        previewThumbnails: {\n          thumbContainer: \"plyr__preview-thumb\",\n          thumbContainerShown: \"plyr__preview-thumb--is-shown\",\n          imageContainer: \"plyr__preview-thumb__image-container\",\n          timeContainer: \"plyr__preview-thumb__time-container\",\n          scrubbingContainer: \"plyr__preview-scrubbing\",\n          scrubbingContainerShown: \"plyr__preview-scrubbing--is-shown\"\n        }\n      },\n      attributes: {\n        embed: {\n          provider: \"data-plyr-provider\",\n          id: \"data-plyr-embed-id\",\n          hash: \"data-plyr-embed-hash\"\n        }\n      },\n      ads: {\n        enabled: !1,\n        publisherId: \"\",\n        tagUrl: \"\"\n      },\n      previewThumbnails: {\n        enabled: !1,\n        src: \"\"\n      },\n      vimeo: {\n        byline: !1,\n        portrait: !1,\n        title: !1,\n        speed: !0,\n        transparent: !1,\n        customControls: !0,\n        referrerPolicy: null,\n        premium: !1\n      },\n      youtube: {\n        rel: 0,\n        showinfo: 0,\n        iv_load_policy: 3,\n        modestbranding: 1,\n        customControls: !0,\n        noCookie: !1\n      }\n    },\n    Xe = \"picture-in-picture\",\n    Je = \"inline\",\n    Ge = {\n      html5: \"html5\",\n      youtube: \"youtube\",\n      vimeo: \"vimeo\"\n    },\n    Ze = \"audio\",\n    et = \"video\";\n  const tt = () => {};\n  class it {\n    constructor(e = !1) {\n      this.enabled = window.console && e, this.enabled && this.log(\"Debugging enabled\");\n    }\n    get log() {\n      return this.enabled ? Function.prototype.bind.call(console.log, console) : tt;\n    }\n    get warn() {\n      return this.enabled ? Function.prototype.bind.call(console.warn, console) : tt;\n    }\n    get error() {\n      return this.enabled ? Function.prototype.bind.call(console.error, console) : tt;\n    }\n  }\n  class st {\n    constructor(t) {\n      e(this, \"onChange\", () => {\n        if (!this.enabled) return;\n        const e = this.player.elements.buttons.fullscreen;\n        H(e) && (e.pressed = this.active);\n        const t = this.target === this.player.media ? this.target : this.player.elements.container;\n        ve.call(this.player, t, this.active ? \"enterfullscreen\" : \"exitfullscreen\", !0);\n      }), e(this, \"toggleFallback\", (e = !1) => {\n        if (e ? this.scrollPosition = {\n          x: window.scrollX || 0,\n          y: window.scrollY || 0\n        } : window.scrollTo(this.scrollPosition.x, this.scrollPosition.y), document.body.style.overflow = e ? \"hidden\" : \"\", le(this.target, this.player.config.classNames.fullscreen.fallback, e), Y.isIos) {\n          let t = document.head.querySelector('meta[name=\"viewport\"]');\n          const i = \"viewport-fit=cover\";\n          t || (t = document.createElement(\"meta\"), t.setAttribute(\"name\", \"viewport\"));\n          const s = _(t.content) && t.content.includes(i);\n          e ? (this.cleanupViewport = !s, s || (t.content += `,${i}`)) : this.cleanupViewport && (t.content = t.content.split(\",\").filter(e => e.trim() !== i).join(\",\"));\n        }\n        this.onChange();\n      }), e(this, \"trapFocus\", e => {\n        if (Y.isIos || !this.active || \"Tab\" !== e.key || 9 !== e.keyCode) return;\n        const t = document.activeElement,\n          i = ce.call(this.player, \"a[href], button:not(:disabled), input:not(:disabled), [tabindex]\"),\n          [s] = i,\n          n = i[i.length - 1];\n        t !== n || e.shiftKey ? t === s && e.shiftKey && (n.focus(), e.preventDefault()) : (s.focus(), e.preventDefault());\n      }), e(this, \"update\", () => {\n        if (this.enabled) {\n          let e;\n          e = this.forceFallback ? \"Fallback (forced)\" : st.native ? \"Native\" : \"Fallback\", this.player.debug.log(`${e} fullscreen enabled`);\n        } else this.player.debug.log(\"Fullscreen not supported and fallback disabled\");\n        le(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.enabled);\n      }), e(this, \"enter\", () => {\n        this.enabled && (Y.isIos && this.player.config.fullscreen.iosNative ? this.player.isVimeo ? this.player.embed.requestFullscreen() : this.target.webkitEnterFullscreen() : !st.native || this.forceFallback ? this.toggleFallback(!0) : this.prefix ? W(this.prefix) || this.target[`${this.prefix}Request${this.property}`]() : this.target.requestFullscreen({\n          navigationUI: \"hide\"\n        }));\n      }), e(this, \"exit\", () => {\n        if (this.enabled) if (Y.isIos && this.player.config.fullscreen.iosNative) this.target.webkitExitFullscreen(), ke(this.player.play());else if (!st.native || this.forceFallback) this.toggleFallback(!1);else if (this.prefix) {\n          if (!W(this.prefix)) {\n            const e = \"moz\" === this.prefix ? \"Cancel\" : \"Exit\";\n            document[`${this.prefix}${e}${this.property}`]();\n          }\n        } else (document.cancelFullScreen || document.exitFullscreen).call(document);\n      }), e(this, \"toggle\", () => {\n        this.active ? this.exit() : this.enter();\n      }), this.player = t, this.prefix = st.prefix, this.property = st.property, this.scrollPosition = {\n        x: 0,\n        y: 0\n      }, this.forceFallback = \"force\" === t.config.fullscreen.fallback, this.player.elements.fullscreen = t.config.fullscreen.container && function (e, t) {\n        const {\n          prototype: i\n        } = Element;\n        return (i.closest || function () {\n          let e = this;\n          do {\n            if (re.matches(e, t)) return e;\n            e = e.parentElement || e.parentNode;\n          } while (null !== e && 1 === e.nodeType);\n          return null;\n        }).call(e, t);\n      }(this.player.elements.container, t.config.fullscreen.container), fe.call(this.player, document, \"ms\" === this.prefix ? \"MSFullscreenChange\" : `${this.prefix}fullscreenchange`, () => {\n        this.onChange();\n      }), fe.call(this.player, this.player.elements.container, \"dblclick\", e => {\n        H(this.player.elements.controls) && this.player.elements.controls.contains(e.target) || this.player.listeners.proxy(e, this.toggle, \"fullscreen\");\n      }), fe.call(this, this.player.elements.container, \"keydown\", e => this.trapFocus(e)), this.update();\n    }\n    static get native() {\n      return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);\n    }\n    get usingNative() {\n      return st.native && !this.forceFallback;\n    }\n    static get prefix() {\n      if (j(document.exitFullscreen)) return \"\";\n      let e = \"\";\n      return [\"webkit\", \"moz\", \"ms\"].some(t => !(!j(document[`${t}ExitFullscreen`]) && !j(document[`${t}CancelFullScreen`])) && (e = t, !0)), e;\n    }\n    static get property() {\n      return \"moz\" === this.prefix ? \"FullScreen\" : \"Fullscreen\";\n    }\n    get enabled() {\n      return (st.native || this.player.config.fullscreen.fallback) && this.player.config.fullscreen.enabled && this.player.supported.ui && this.player.isVideo;\n    }\n    get active() {\n      if (!this.enabled) return !1;\n      if (!st.native || this.forceFallback) return oe(this.target, this.player.config.classNames.fullscreen.fallback);\n      const e = this.prefix ? this.target.getRootNode()[`${this.prefix}${this.property}Element`] : this.target.getRootNode().fullscreenElement;\n      return e && e.shadowRoot ? e === this.target.getRootNode().host : e === this.target;\n    }\n    get target() {\n      return Y.isIos && this.player.config.fullscreen.iosNative ? this.player.media : this.player.elements.fullscreen || this.player.elements.container;\n    }\n  }\n  function nt(e, t = 1) {\n    return new Promise((i, s) => {\n      const n = new Image(),\n        a = () => {\n          delete n.onload, delete n.onerror, (n.naturalWidth >= t ? i : s)(n);\n        };\n      Object.assign(n, {\n        onload: a,\n        onerror: a,\n        src: e\n      });\n    });\n  }\n  const at = {\n    addStyleHook() {\n      le(this.elements.container, this.config.selectors.container.replace(\".\", \"\"), !0), le(this.elements.container, this.config.classNames.uiSupported, this.supported.ui);\n    },\n    toggleNativeControls(e = !1) {\n      e && this.isHTML5 ? this.media.setAttribute(\"controls\", \"\") : this.media.removeAttribute(\"controls\");\n    },\n    build() {\n      if (this.listeners.media(), !this.supported.ui) return this.debug.warn(`Basic support only for ${this.provider} ${this.type}`), void at.toggleNativeControls.call(this, !0);\n      H(this.elements.controls) || (We.inject.call(this), this.listeners.controls()), at.toggleNativeControls.call(this), this.isHTML5 && Ye.setup.call(this), this.volume = null, this.muted = null, this.loop = null, this.quality = null, this.speed = null, We.updateVolume.call(this), We.timeUpdate.call(this), We.durationUpdate.call(this), at.checkPlaying.call(this), le(this.elements.container, this.config.classNames.pip.supported, me.pip && this.isHTML5 && this.isVideo), le(this.elements.container, this.config.classNames.airplay.supported, me.airplay && this.isHTML5), le(this.elements.container, this.config.classNames.isIos, Y.isIos), le(this.elements.container, this.config.classNames.isTouch, this.touch), this.ready = !0, setTimeout(() => {\n        ve.call(this, this.media, \"ready\");\n      }, 0), at.setTitle.call(this), this.poster && at.setPoster.call(this, this.poster, !1).catch(() => {}), this.config.duration && We.durationUpdate.call(this);\n    },\n    setTitle() {\n      let e = He.get(\"play\", this.config);\n      if (_(this.config.title) && !W(this.config.title) && (e += `, ${this.config.title}`), Array.from(this.elements.buttons.play || []).forEach(t => {\n        t.setAttribute(\"aria-label\", e);\n      }), this.isEmbed) {\n        const e = he.call(this, \"iframe\");\n        if (!H(e)) return;\n        const t = W(this.config.title) ? \"video\" : this.config.title,\n          i = He.get(\"frameTitle\", this.config);\n        e.setAttribute(\"title\", i.replace(\"{title}\", t));\n      }\n    },\n    togglePoster(e) {\n      le(this.elements.container, this.config.classNames.posterEnabled, e);\n    },\n    setPoster(e, t = !0) {\n      return t && this.poster ? Promise.reject(new Error(\"Poster already set\")) : (this.media.setAttribute(\"data-poster\", e), this.elements.poster.removeAttribute(\"hidden\"), Te.call(this).then(() => nt(e)).catch(t => {\n        throw e === this.poster && at.togglePoster.call(this, !1), t;\n      }).then(() => {\n        if (e !== this.poster) throw new Error(\"setPoster cancelled by later call to setPoster\");\n      }).then(() => (Object.assign(this.elements.poster.style, {\n        backgroundImage: `url('${e}')`,\n        backgroundSize: \"\"\n      }), at.togglePoster.call(this, !0), e)));\n    },\n    checkPlaying(e) {\n      le(this.elements.container, this.config.classNames.playing, this.playing), le(this.elements.container, this.config.classNames.paused, this.paused), le(this.elements.container, this.config.classNames.stopped, this.stopped), Array.from(this.elements.buttons.play || []).forEach(e => {\n        Object.assign(e, {\n          pressed: this.playing\n        }), e.setAttribute(\"aria-label\", He.get(this.playing ? \"pause\" : \"play\", this.config));\n      }), F(e) && \"timeupdate\" === e.type || at.toggleControls.call(this);\n    },\n    checkLoading(e) {\n      this.loading = [\"stalled\", \"waiting\"].includes(e.type), clearTimeout(this.timers.loading), this.timers.loading = setTimeout(() => {\n        le(this.elements.container, this.config.classNames.loading, this.loading), at.toggleControls.call(this);\n      }, this.loading ? 250 : 0);\n    },\n    toggleControls(e) {\n      const {\n        controls: t\n      } = this.elements;\n      if (t && this.config.hideControls) {\n        const i = this.touch && this.lastSeekTime + 2e3 > Date.now();\n        this.toggleControls(Boolean(e || this.loading || this.paused || t.pressed || t.hover || i));\n      }\n    },\n    migrateStyles() {\n      Object.values({\n        ...this.media.style\n      }).filter(e => !W(e) && _(e) && e.startsWith(\"--plyr\")).forEach(e => {\n        this.elements.container.style.setProperty(e, this.media.style.getPropertyValue(e)), this.media.style.removeProperty(e);\n      }), W(this.media.style) && this.media.removeAttribute(\"style\");\n    }\n  };\n  class lt {\n    constructor(t) {\n      e(this, \"firstTouch\", () => {\n        const {\n            player: e\n          } = this,\n          {\n            elements: t\n          } = e;\n        e.touch = !0, le(t.container, e.config.classNames.isTouch, !0);\n      }), e(this, \"setTabFocus\", e => {\n        const {\n            player: t\n          } = this,\n          {\n            elements: i\n          } = t;\n        if (clearTimeout(this.focusTimer), \"keydown\" === e.type && 9 !== e.which) return;\n        \"keydown\" === e.type && (this.lastKeyDown = e.timeStamp);\n        const s = e.timeStamp - this.lastKeyDown <= 20;\n        (\"focus\" !== e.type || s) && ((() => {\n          const e = t.config.classNames.tabFocus;\n          le(ce.call(t, `.${e}`), e, !1);\n        })(), \"focusout\" !== e.type && (this.focusTimer = setTimeout(() => {\n          const e = document.activeElement;\n          i.container.contains(e) && le(document.activeElement, t.config.classNames.tabFocus, !0);\n        }, 10)));\n      }), e(this, \"global\", (e = !0) => {\n        const {\n          player: t\n        } = this;\n        t.config.keyboard.global && ge.call(t, window, \"keydown keyup\", this.handleKey, e, !1), ge.call(t, document.body, \"click\", this.toggleMenu, e), ye.call(t, document.body, \"touchstart\", this.firstTouch), ge.call(t, document.body, \"keydown focus blur focusout\", this.setTabFocus, e, !1, !0);\n      }), e(this, \"container\", () => {\n        const {\n            player: e\n          } = this,\n          {\n            config: t,\n            elements: i,\n            timers: s\n          } = e;\n        !t.keyboard.global && t.keyboard.focused && fe.call(e, i.container, \"keydown keyup\", this.handleKey, !1), fe.call(e, i.container, \"mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen\", t => {\n          const {\n            controls: n\n          } = i;\n          n && \"enterfullscreen\" === t.type && (n.pressed = !1, n.hover = !1);\n          let a = 0;\n          [\"touchstart\", \"touchmove\", \"mousemove\"].includes(t.type) && (at.toggleControls.call(e, !0), a = e.touch ? 3e3 : 2e3), clearTimeout(s.controls), s.controls = setTimeout(() => at.toggleControls.call(e, !1), a);\n        });\n        const n = () => {\n            if (!e.isVimeo || e.config.vimeo.premium) return;\n            const t = i.wrapper,\n              {\n                active: s\n              } = e.fullscreen,\n              [n, a] = xe.call(e),\n              l = Se(`aspect-ratio: ${n} / ${a}`);\n            if (!s) return void (l ? (t.style.width = null, t.style.height = null) : (t.style.maxWidth = null, t.style.margin = null));\n            const [o, r] = [Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0), Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)],\n              c = o / r > n / a;\n            l ? (t.style.width = c ? \"auto\" : \"100%\", t.style.height = c ? \"100%\" : \"auto\") : (t.style.maxWidth = c ? r / a * n + \"px\" : null, t.style.margin = c ? \"0 auto\" : null);\n          },\n          a = () => {\n            clearTimeout(s.resized), s.resized = setTimeout(n, 50);\n          };\n        fe.call(e, i.container, \"enterfullscreen exitfullscreen\", t => {\n          const {\n            target: s\n          } = e.fullscreen;\n          if (s !== i.container) return;\n          if (!e.isEmbed && W(e.config.ratio)) return;\n          n();\n          (\"enterfullscreen\" === t.type ? fe : be).call(e, window, \"resize\", a);\n        });\n      }), e(this, \"media\", () => {\n        const {\n            player: e\n          } = this,\n          {\n            elements: t\n          } = e;\n        if (fe.call(e, e.media, \"timeupdate seeking seeked\", t => We.timeUpdate.call(e, t)), fe.call(e, e.media, \"durationchange loadeddata loadedmetadata\", t => We.durationUpdate.call(e, t)), fe.call(e, e.media, \"ended\", () => {\n          e.isHTML5 && e.isVideo && e.config.resetOnEnd && (e.restart(), e.pause());\n        }), fe.call(e, e.media, \"progress playing seeking seeked\", t => We.updateProgress.call(e, t)), fe.call(e, e.media, \"volumechange\", t => We.updateVolume.call(e, t)), fe.call(e, e.media, \"playing play pause ended emptied timeupdate\", t => at.checkPlaying.call(e, t)), fe.call(e, e.media, \"waiting canplay seeked playing\", t => at.checkLoading.call(e, t)), e.supported.ui && e.config.clickToPlay && !e.isAudio) {\n          const i = he.call(e, `.${e.config.classNames.video}`);\n          if (!H(i)) return;\n          fe.call(e, t.container, \"click\", s => {\n            ([t.container, i].includes(s.target) || i.contains(s.target)) && (e.touch && e.config.hideControls || (e.ended ? (this.proxy(s, e.restart, \"restart\"), this.proxy(s, () => {\n              ke(e.play());\n            }, \"play\")) : this.proxy(s, () => {\n              ke(e.togglePlay());\n            }, \"play\")));\n          });\n        }\n        e.supported.ui && e.config.disableContextMenu && fe.call(e, t.wrapper, \"contextmenu\", e => {\n          e.preventDefault();\n        }, !1), fe.call(e, e.media, \"volumechange\", () => {\n          e.storage.set({\n            volume: e.volume,\n            muted: e.muted\n          });\n        }), fe.call(e, e.media, \"ratechange\", () => {\n          We.updateSetting.call(e, \"speed\"), e.storage.set({\n            speed: e.speed\n          });\n        }), fe.call(e, e.media, \"qualitychange\", t => {\n          We.updateSetting.call(e, \"quality\", null, t.detail.quality);\n        }), fe.call(e, e.media, \"ready qualitychange\", () => {\n          We.setDownloadUrl.call(e);\n        });\n        const i = e.config.events.concat([\"keyup\", \"keydown\"]).join(\" \");\n        fe.call(e, e.media, i, i => {\n          let {\n            detail: s = {}\n          } = i;\n          \"error\" === i.type && (s = e.media.error), ve.call(e, t.container, i.type, !0, s);\n        });\n      }), e(this, \"proxy\", (e, t, i) => {\n        const {\n            player: s\n          } = this,\n          n = s.config.listeners[i];\n        let a = !0;\n        j(n) && (a = n.call(s, e)), !1 !== a && j(t) && t.call(s, e);\n      }), e(this, \"bind\", (e, t, i, s, n = !0) => {\n        const {\n            player: a\n          } = this,\n          l = a.config.listeners[s],\n          o = j(l);\n        fe.call(a, e, t, e => this.proxy(e, i, s), n && !o);\n      }), e(this, \"controls\", () => {\n        const {\n            player: e\n          } = this,\n          {\n            elements: t\n          } = e,\n          i = Y.isIE ? \"change\" : \"input\";\n        if (t.buttons.play && Array.from(t.buttons.play).forEach(t => {\n          this.bind(t, \"click\", () => {\n            ke(e.togglePlay());\n          }, \"play\");\n        }), this.bind(t.buttons.restart, \"click\", e.restart, \"restart\"), this.bind(t.buttons.rewind, \"click\", () => {\n          e.lastSeekTime = Date.now(), e.rewind();\n        }, \"rewind\"), this.bind(t.buttons.fastForward, \"click\", () => {\n          e.lastSeekTime = Date.now(), e.forward();\n        }, \"fastForward\"), this.bind(t.buttons.mute, \"click\", () => {\n          e.muted = !e.muted;\n        }, \"mute\"), this.bind(t.buttons.captions, \"click\", () => e.toggleCaptions()), this.bind(t.buttons.download, \"click\", () => {\n          ve.call(e, e.media, \"download\");\n        }, \"download\"), this.bind(t.buttons.fullscreen, \"click\", () => {\n          e.fullscreen.toggle();\n        }, \"fullscreen\"), this.bind(t.buttons.pip, \"click\", () => {\n          e.pip = \"toggle\";\n        }, \"pip\"), this.bind(t.buttons.airplay, \"click\", e.airplay, \"airplay\"), this.bind(t.buttons.settings, \"click\", t => {\n          t.stopPropagation(), t.preventDefault(), We.toggleMenu.call(e, t);\n        }, null, !1), this.bind(t.buttons.settings, \"keyup\", t => {\n          const i = t.which;\n          [13, 32].includes(i) && (13 !== i ? (t.preventDefault(), t.stopPropagation(), We.toggleMenu.call(e, t)) : We.focusFirstMenuItem.call(e, null, !0));\n        }, null, !1), this.bind(t.settings.menu, \"keydown\", t => {\n          27 === t.which && We.toggleMenu.call(e, t);\n        }), this.bind(t.inputs.seek, \"mousedown mousemove\", e => {\n          const i = t.progress.getBoundingClientRect(),\n            s = 100 / i.width * (e.pageX - i.left);\n          e.currentTarget.setAttribute(\"seek-value\", s);\n        }), this.bind(t.inputs.seek, \"mousedown mouseup keydown keyup touchstart touchend\", t => {\n          const i = t.currentTarget,\n            s = t.keyCode ? t.keyCode : t.which,\n            n = \"play-on-seeked\";\n          if (R(t) && 39 !== s && 37 !== s) return;\n          e.lastSeekTime = Date.now();\n          const a = i.hasAttribute(n),\n            l = [\"mouseup\", \"touchend\", \"keyup\"].includes(t.type);\n          a && l ? (i.removeAttribute(n), ke(e.play())) : !l && e.playing && (i.setAttribute(n, \"\"), e.pause());\n        }), Y.isIos) {\n          const t = ce.call(e, 'input[type=\"range\"]');\n          Array.from(t).forEach(e => this.bind(e, i, e => K(e.target)));\n        }\n        this.bind(t.inputs.seek, i, t => {\n          const i = t.currentTarget;\n          let s = i.getAttribute(\"seek-value\");\n          W(s) && (s = i.value), i.removeAttribute(\"seek-value\"), e.currentTime = s / i.max * e.duration;\n        }, \"seek\"), this.bind(t.progress, \"mouseenter mouseleave mousemove\", t => We.updateSeekTooltip.call(e, t)), this.bind(t.progress, \"mousemove touchmove\", t => {\n          const {\n            previewThumbnails: i\n          } = e;\n          i && i.loaded && i.startMove(t);\n        }), this.bind(t.progress, \"mouseleave touchend click\", () => {\n          const {\n            previewThumbnails: t\n          } = e;\n          t && t.loaded && t.endMove(!1, !0);\n        }), this.bind(t.progress, \"mousedown touchstart\", t => {\n          const {\n            previewThumbnails: i\n          } = e;\n          i && i.loaded && i.startScrubbing(t);\n        }), this.bind(t.progress, \"mouseup touchend\", t => {\n          const {\n            previewThumbnails: i\n          } = e;\n          i && i.loaded && i.endScrubbing(t);\n        }), Y.isWebkit && Array.from(ce.call(e, 'input[type=\"range\"]')).forEach(t => {\n          this.bind(t, \"input\", t => We.updateRangeFill.call(e, t.target));\n        }), e.config.toggleInvert && !H(t.display.duration) && this.bind(t.display.currentTime, \"click\", () => {\n          0 !== e.currentTime && (e.config.invertTime = !e.config.invertTime, We.timeUpdate.call(e));\n        }), this.bind(t.inputs.volume, i, t => {\n          e.volume = t.target.value;\n        }, \"volume\"), this.bind(t.controls, \"mouseenter mouseleave\", i => {\n          t.controls.hover = !e.touch && \"mouseenter\" === i.type;\n        }), t.fullscreen && Array.from(t.fullscreen.children).filter(e => !e.contains(t.container)).forEach(i => {\n          this.bind(i, \"mouseenter mouseleave\", i => {\n            t.controls && (t.controls.hover = !e.touch && \"mouseenter\" === i.type);\n          });\n        }), this.bind(t.controls, \"mousedown mouseup touchstart touchend touchcancel\", e => {\n          t.controls.pressed = [\"mousedown\", \"touchstart\"].includes(e.type);\n        }), this.bind(t.controls, \"focusin\", () => {\n          const {\n            config: i,\n            timers: s\n          } = e;\n          le(t.controls, i.classNames.noTransition, !0), at.toggleControls.call(e, !0), setTimeout(() => {\n            le(t.controls, i.classNames.noTransition, !1);\n          }, 0);\n          const n = this.touch ? 3e3 : 4e3;\n          clearTimeout(s.controls), s.controls = setTimeout(() => at.toggleControls.call(e, !1), n);\n        }), this.bind(t.inputs.volume, \"wheel\", t => {\n          const i = t.webkitDirectionInvertedFromDevice,\n            [s, n] = [t.deltaX, -t.deltaY].map(e => i ? -e : e),\n            a = Math.sign(Math.abs(s) > Math.abs(n) ? s : n);\n          e.increaseVolume(a / 50);\n          const {\n            volume: l\n          } = e.media;\n          (1 === a && l < 1 || -1 === a && l > 0) && t.preventDefault();\n        }, \"volume\", !1);\n      }), this.player = t, this.lastKey = null, this.focusTimer = null, this.lastKeyDown = null, this.handleKey = this.handleKey.bind(this), this.toggleMenu = this.toggleMenu.bind(this), this.setTabFocus = this.setTabFocus.bind(this), this.firstTouch = this.firstTouch.bind(this);\n    }\n    handleKey(e) {\n      const {\n          player: t\n        } = this,\n        {\n          elements: i\n        } = t,\n        s = e.keyCode ? e.keyCode : e.which,\n        n = \"keydown\" === e.type,\n        a = n && s === this.lastKey;\n      if (e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) return;\n      if (!$(s)) return;\n      if (n) {\n        const n = document.activeElement;\n        if (H(n)) {\n          const {\n              editable: s\n            } = t.config.selectors,\n            {\n              seek: a\n            } = i.inputs;\n          if (n !== a && re(n, s)) return;\n          if (32 === e.which && re(n, 'button, [role^=\"menuitem\"]')) return;\n        }\n        switch ([32, 37, 38, 39, 40, 48, 49, 50, 51, 52, 53, 54, 56, 57, 67, 70, 73, 75, 76, 77, 79].includes(s) && (e.preventDefault(), e.stopPropagation()), s) {\n          case 48:\n          case 49:\n          case 50:\n          case 51:\n          case 52:\n          case 53:\n          case 54:\n          case 55:\n          case 56:\n          case 57:\n            a || (t.currentTime = t.duration / 10 * (s - 48));\n            break;\n          case 32:\n          case 75:\n            a || ke(t.togglePlay());\n            break;\n          case 38:\n            t.increaseVolume(.1);\n            break;\n          case 40:\n            t.decreaseVolume(.1);\n            break;\n          case 77:\n            a || (t.muted = !t.muted);\n            break;\n          case 39:\n            t.forward();\n            break;\n          case 37:\n            t.rewind();\n            break;\n          case 70:\n            t.fullscreen.toggle();\n            break;\n          case 67:\n            a || t.toggleCaptions();\n            break;\n          case 76:\n            t.loop = !t.loop;\n        }\n        27 === s && !t.fullscreen.usingNative && t.fullscreen.active && t.fullscreen.toggle(), this.lastKey = s;\n      } else this.lastKey = null;\n    }\n    toggleMenu(e) {\n      We.toggleMenu.call(this.player, e);\n    }\n  }\n  \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self && self;\n  var ot = function (e, t) {\n    return e(t = {\n      exports: {}\n    }, t.exports), t.exports;\n  }(function (e, t) {\n    e.exports = function () {\n      var e = function () {},\n        t = {},\n        i = {},\n        s = {};\n      function n(e, t) {\n        e = e.push ? e : [e];\n        var n,\n          a,\n          l,\n          o = [],\n          r = e.length,\n          c = r;\n        for (n = function (e, i) {\n          i.length && o.push(e), --c || t(o);\n        }; r--;) a = e[r], (l = i[a]) ? n(a, l) : (s[a] = s[a] || []).push(n);\n      }\n      function a(e, t) {\n        if (e) {\n          var n = s[e];\n          if (i[e] = t, n) for (; n.length;) n[0](e, t), n.splice(0, 1);\n        }\n      }\n      function l(t, i) {\n        t.call && (t = {\n          success: t\n        }), i.length ? (t.error || e)(i) : (t.success || e)(t);\n      }\n      function o(t, i, s, n) {\n        var a,\n          l,\n          r = document,\n          c = s.async,\n          h = (s.numRetries || 0) + 1,\n          u = s.before || e,\n          d = t.replace(/[\\?|#].*$/, \"\"),\n          m = t.replace(/^(css|img)!/, \"\");\n        n = n || 0, /(^css!|\\.css$)/.test(d) ? ((l = r.createElement(\"link\")).rel = \"stylesheet\", l.href = m, (a = \"hideFocus\" in l) && l.relList && (a = 0, l.rel = \"preload\", l.as = \"style\")) : /(^img!|\\.(png|gif|jpg|svg|webp)$)/.test(d) ? (l = r.createElement(\"img\")).src = m : ((l = r.createElement(\"script\")).src = t, l.async = void 0 === c || c), l.onload = l.onerror = l.onbeforeload = function (e) {\n          var r = e.type[0];\n          if (a) try {\n            l.sheet.cssText.length || (r = \"e\");\n          } catch (e) {\n            18 != e.code && (r = \"e\");\n          }\n          if (\"e\" == r) {\n            if ((n += 1) < h) return o(t, i, s, n);\n          } else if (\"preload\" == l.rel && \"style\" == l.as) return l.rel = \"stylesheet\";\n          i(t, r, e.defaultPrevented);\n        }, !1 !== u(t, l) && r.head.appendChild(l);\n      }\n      function r(e, t, i) {\n        var s,\n          n,\n          a = (e = e.push ? e : [e]).length,\n          l = a,\n          r = [];\n        for (s = function (e, i, s) {\n          if (\"e\" == i && r.push(e), \"b\" == i) {\n            if (!s) return;\n            r.push(e);\n          }\n          --a || t(r);\n        }, n = 0; n < l; n++) o(e[n], s, i);\n      }\n      function c(e, i, s) {\n        var n, o;\n        if (i && i.trim && (n = i), o = (n ? s : i) || {}, n) {\n          if (n in t) throw \"LoadJS\";\n          t[n] = !0;\n        }\n        function c(t, i) {\n          r(e, function (e) {\n            l(o, e), t && l({\n              success: t,\n              error: i\n            }, e), a(n, e);\n          }, o);\n        }\n        if (o.returnPromise) return new Promise(c);\n        c();\n      }\n      return c.ready = function (e, t) {\n        return n(e, function (e) {\n          l(t, e);\n        }), c;\n      }, c.done = function (e) {\n        a(e, []);\n      }, c.reset = function () {\n        t = {}, i = {}, s = {};\n      }, c.isDefined = function (e) {\n        return e in t;\n      }, c;\n    }();\n  });\n  function rt(e) {\n    return new Promise((t, i) => {\n      ot(e, {\n        success: t,\n        error: i\n      });\n    });\n  }\n  function ct(e) {\n    e && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === e && (this.media.paused = !e, ve.call(this, this.media, e ? \"play\" : \"pause\"));\n  }\n  const ht = {\n    setup() {\n      const e = this;\n      le(e.elements.wrapper, e.config.classNames.embed, !0), e.options.speed = e.config.speed.options, Me.call(e), L(window.Vimeo) ? ht.ready.call(e) : rt(e.config.urls.vimeo.sdk).then(() => {\n        ht.ready.call(e);\n      }).catch(t => {\n        e.debug.warn(\"Vimeo SDK (player.js) failed to load\", t);\n      });\n    },\n    ready() {\n      const e = this,\n        t = e.config.vimeo,\n        {\n          premium: i,\n          referrerPolicy: s,\n          ...n\n        } = t;\n      let a = e.media.getAttribute(\"src\"),\n        l = \"\";\n      W(a) ? (a = e.media.getAttribute(e.config.attributes.embed.id), l = e.media.getAttribute(e.config.attributes.embed.hash)) : l = function (e) {\n        const t = e.match(/^.*(?:vimeo.com\\/|video\\/)(?:\\d+)(?:\\?.*&*h=|\\/)+(?<hash>[\\d,a-f]+)/);\n        return t ? t.groups.hash : null;\n      }(a);\n      const o = l ? {\n        h: l\n      } : {};\n      i && Object.assign(n, {\n        controls: !1,\n        sidedock: !1\n      });\n      const r = Ke({\n          loop: e.config.loop.active,\n          autoplay: e.autoplay,\n          muted: e.muted,\n          gesture: \"media\",\n          playsinline: !this.config.fullscreen.iosNative,\n          ...o,\n          ...n\n        }),\n        c = W(h = a) ? null : $(Number(h)) ? h : h.match(/^.*(vimeo.com\\/|video\\/)(\\d+).*/) ? RegExp.$2 : h;\n      var h;\n      const u = Z(\"iframe\"),\n        d = $e(e.config.urls.vimeo.iframe, c, r);\n      if (u.setAttribute(\"src\", d), u.setAttribute(\"allowfullscreen\", \"\"), u.setAttribute(\"allow\", [\"autoplay\", \"fullscreen\", \"picture-in-picture\", \"encrypted-media\", \"accelerometer\", \"gyroscope\"].join(\"; \")), W(s) || u.setAttribute(\"referrerPolicy\", s), i || !t.customControls) u.setAttribute(\"data-poster\", e.poster), e.media = se(u, e.media);else {\n        const t = Z(\"div\", {\n          class: e.config.classNames.embedContainer,\n          \"data-poster\": e.poster\n        });\n        t.appendChild(u), e.media = se(t, e.media);\n      }\n      t.customControls || Re($e(e.config.urls.vimeo.api, d)).then(t => {\n        !W(t) && t.thumbnail_url && at.setPoster.call(e, t.thumbnail_url).catch(() => {});\n      }), e.embed = new window.Vimeo.Player(u, {\n        autopause: e.config.autopause,\n        muted: e.muted\n      }), e.media.paused = !0, e.media.currentTime = 0, e.supported.ui && e.embed.disableTextTrack(), e.media.play = () => (ct.call(e, !0), e.embed.play()), e.media.pause = () => (ct.call(e, !1), e.embed.pause()), e.media.stop = () => {\n        e.pause(), e.currentTime = 0;\n      };\n      let {\n        currentTime: m\n      } = e.media;\n      Object.defineProperty(e.media, \"currentTime\", {\n        get: () => m,\n        set(t) {\n          const {\n              embed: i,\n              media: s,\n              paused: n,\n              volume: a\n            } = e,\n            l = n && !i.hasPlayed;\n          s.seeking = !0, ve.call(e, s, \"seeking\"), Promise.resolve(l && i.setVolume(0)).then(() => i.setCurrentTime(t)).then(() => l && i.pause()).then(() => l && i.setVolume(a)).catch(() => {});\n        }\n      });\n      let p = e.config.speed.selected;\n      Object.defineProperty(e.media, \"playbackRate\", {\n        get: () => p,\n        set(t) {\n          e.embed.setPlaybackRate(t).then(() => {\n            p = t, ve.call(e, e.media, \"ratechange\");\n          }).catch(() => {\n            e.options.speed = [1];\n          });\n        }\n      });\n      let {\n        volume: g\n      } = e.config;\n      Object.defineProperty(e.media, \"volume\", {\n        get: () => g,\n        set(t) {\n          e.embed.setVolume(t).then(() => {\n            g = t, ve.call(e, e.media, \"volumechange\");\n          });\n        }\n      });\n      let {\n        muted: f\n      } = e.config;\n      Object.defineProperty(e.media, \"muted\", {\n        get: () => f,\n        set(t) {\n          const i = !!O(t) && t;\n          e.embed.setVolume(i ? 0 : e.config.volume).then(() => {\n            f = i, ve.call(e, e.media, \"volumechange\");\n          });\n        }\n      });\n      let b,\n        {\n          loop: y\n        } = e.config;\n      Object.defineProperty(e.media, \"loop\", {\n        get: () => y,\n        set(t) {\n          const i = O(t) ? t : e.config.loop.active;\n          e.embed.setLoop(i).then(() => {\n            y = i;\n          });\n        }\n      }), e.embed.getVideoUrl().then(t => {\n        b = t, We.setDownloadUrl.call(e);\n      }).catch(e => {\n        this.debug.warn(e);\n      }), Object.defineProperty(e.media, \"currentSrc\", {\n        get: () => b\n      }), Object.defineProperty(e.media, \"ended\", {\n        get: () => e.currentTime === e.duration\n      }), Promise.all([e.embed.getVideoWidth(), e.embed.getVideoHeight()]).then(t => {\n        const [i, s] = t;\n        e.embed.ratio = Ie(i, s), Me.call(this);\n      }), e.embed.setAutopause(e.config.autopause).then(t => {\n        e.config.autopause = t;\n      }), e.embed.getVideoTitle().then(t => {\n        e.config.title = t, at.setTitle.call(this);\n      }), e.embed.getCurrentTime().then(t => {\n        m = t, ve.call(e, e.media, \"timeupdate\");\n      }), e.embed.getDuration().then(t => {\n        e.media.duration = t, ve.call(e, e.media, \"durationchange\");\n      }), e.embed.getTextTracks().then(t => {\n        e.media.textTracks = t, Ye.setup.call(e);\n      }), e.embed.on(\"cuechange\", ({\n        cues: t = []\n      }) => {\n        const i = t.map(e => function (e) {\n          const t = document.createDocumentFragment(),\n            i = document.createElement(\"div\");\n          return t.appendChild(i), i.innerHTML = e, t.firstChild.innerText;\n        }(e.text));\n        Ye.updateCues.call(e, i);\n      }), e.embed.on(\"loaded\", () => {\n        if (e.embed.getPaused().then(t => {\n          ct.call(e, !t), t || ve.call(e, e.media, \"playing\");\n        }), H(e.embed.element) && e.supported.ui) {\n          e.embed.element.setAttribute(\"tabindex\", -1);\n        }\n      }), e.embed.on(\"bufferstart\", () => {\n        ve.call(e, e.media, \"waiting\");\n      }), e.embed.on(\"bufferend\", () => {\n        ve.call(e, e.media, \"playing\");\n      }), e.embed.on(\"play\", () => {\n        ct.call(e, !0), ve.call(e, e.media, \"playing\");\n      }), e.embed.on(\"pause\", () => {\n        ct.call(e, !1);\n      }), e.embed.on(\"timeupdate\", t => {\n        e.media.seeking = !1, m = t.seconds, ve.call(e, e.media, \"timeupdate\");\n      }), e.embed.on(\"progress\", t => {\n        e.media.buffered = t.percent, ve.call(e, e.media, \"progress\"), 1 === parseInt(t.percent, 10) && ve.call(e, e.media, \"canplaythrough\"), e.embed.getDuration().then(t => {\n          t !== e.media.duration && (e.media.duration = t, ve.call(e, e.media, \"durationchange\"));\n        });\n      }), e.embed.on(\"seeked\", () => {\n        e.media.seeking = !1, ve.call(e, e.media, \"seeked\");\n      }), e.embed.on(\"ended\", () => {\n        e.media.paused = !0, ve.call(e, e.media, \"ended\");\n      }), e.embed.on(\"error\", t => {\n        e.media.error = t, ve.call(e, e.media, \"error\");\n      }), t.customControls && setTimeout(() => at.build.call(e), 0);\n    }\n  };\n  function ut(e) {\n    e && !this.embed.hasPlayed && (this.embed.hasPlayed = !0), this.media.paused === e && (this.media.paused = !e, ve.call(this, this.media, e ? \"play\" : \"pause\"));\n  }\n  function dt(e) {\n    return e.noCookie ? \"https://www.youtube-nocookie.com\" : \"http:\" === window.location.protocol ? \"http://www.youtube.com\" : void 0;\n  }\n  const mt = {\n      setup() {\n        if (le(this.elements.wrapper, this.config.classNames.embed, !0), L(window.YT) && j(window.YT.Player)) mt.ready.call(this);else {\n          const e = window.onYouTubeIframeAPIReady;\n          window.onYouTubeIframeAPIReady = () => {\n            j(e) && e(), mt.ready.call(this);\n          }, rt(this.config.urls.youtube.sdk).catch(e => {\n            this.debug.warn(\"YouTube API failed to load\", e);\n          });\n        }\n      },\n      getTitle(e) {\n        Re($e(this.config.urls.youtube.api, e)).then(e => {\n          if (L(e)) {\n            const {\n              title: t,\n              height: i,\n              width: s\n            } = e;\n            this.config.title = t, at.setTitle.call(this), this.embed.ratio = Ie(s, i);\n          }\n          Me.call(this);\n        }).catch(() => {\n          Me.call(this);\n        });\n      },\n      ready() {\n        const e = this,\n          t = e.config.youtube,\n          i = e.media && e.media.getAttribute(\"id\");\n        if (!W(i) && i.startsWith(\"youtube-\")) return;\n        let s = e.media.getAttribute(\"src\");\n        W(s) && (s = e.media.getAttribute(this.config.attributes.embed.id));\n        const n = W(a = s) ? null : a.match(/^.*(youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|&v=)([^#&?]*).*/) ? RegExp.$2 : a;\n        var a;\n        const l = Z(\"div\", {\n          id: `${e.provider}-${Math.floor(1e4 * Math.random())}`,\n          \"data-poster\": t.customControls ? e.poster : void 0\n        });\n        if (e.media = se(l, e.media), t.customControls) {\n          const t = e => `https://i.ytimg.com/vi/${n}/${e}default.jpg`;\n          nt(t(\"maxres\"), 121).catch(() => nt(t(\"sd\"), 121)).catch(() => nt(t(\"hq\"))).then(t => at.setPoster.call(e, t.src)).then(t => {\n            t.includes(\"maxres\") || (e.elements.poster.style.backgroundSize = \"cover\");\n          }).catch(() => {});\n        }\n        e.embed = new window.YT.Player(e.media, {\n          videoId: n,\n          host: dt(t),\n          playerVars: X({}, {\n            autoplay: e.config.autoplay ? 1 : 0,\n            hl: e.config.hl,\n            controls: e.supported.ui && t.customControls ? 0 : 1,\n            disablekb: 1,\n            playsinline: e.config.fullscreen.iosNative ? 0 : 1,\n            cc_load_policy: e.captions.active ? 1 : 0,\n            cc_lang_pref: e.config.captions.language,\n            widget_referrer: window ? window.location.href : null\n          }, t),\n          events: {\n            onError(t) {\n              if (!e.media.error) {\n                const i = t.data,\n                  s = {\n                    2: \"The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.\",\n                    5: \"The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.\",\n                    100: \"The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.\",\n                    101: \"The owner of the requested video does not allow it to be played in embedded players.\",\n                    150: \"The owner of the requested video does not allow it to be played in embedded players.\"\n                  }[i] || \"An unknown error occured\";\n                e.media.error = {\n                  code: i,\n                  message: s\n                }, ve.call(e, e.media, \"error\");\n              }\n            },\n            onPlaybackRateChange(t) {\n              const i = t.target;\n              e.media.playbackRate = i.getPlaybackRate(), ve.call(e, e.media, \"ratechange\");\n            },\n            onReady(i) {\n              if (j(e.media.play)) return;\n              const s = i.target;\n              mt.getTitle.call(e, n), e.media.play = () => {\n                ut.call(e, !0), s.playVideo();\n              }, e.media.pause = () => {\n                ut.call(e, !1), s.pauseVideo();\n              }, e.media.stop = () => {\n                s.stopVideo();\n              }, e.media.duration = s.getDuration(), e.media.paused = !0, e.media.currentTime = 0, Object.defineProperty(e.media, \"currentTime\", {\n                get: () => Number(s.getCurrentTime()),\n                set(t) {\n                  e.paused && !e.embed.hasPlayed && e.embed.mute(), e.media.seeking = !0, ve.call(e, e.media, \"seeking\"), s.seekTo(t);\n                }\n              }), Object.defineProperty(e.media, \"playbackRate\", {\n                get: () => s.getPlaybackRate(),\n                set(e) {\n                  s.setPlaybackRate(e);\n                }\n              });\n              let {\n                volume: a\n              } = e.config;\n              Object.defineProperty(e.media, \"volume\", {\n                get: () => a,\n                set(t) {\n                  a = t, s.setVolume(100 * a), ve.call(e, e.media, \"volumechange\");\n                }\n              });\n              let {\n                muted: l\n              } = e.config;\n              Object.defineProperty(e.media, \"muted\", {\n                get: () => l,\n                set(t) {\n                  const i = O(t) ? t : l;\n                  l = i, s[i ? \"mute\" : \"unMute\"](), s.setVolume(100 * a), ve.call(e, e.media, \"volumechange\");\n                }\n              }), Object.defineProperty(e.media, \"currentSrc\", {\n                get: () => s.getVideoUrl()\n              }), Object.defineProperty(e.media, \"ended\", {\n                get: () => e.currentTime === e.duration\n              });\n              const o = s.getAvailablePlaybackRates();\n              e.options.speed = o.filter(t => e.config.speed.options.includes(t)), e.supported.ui && t.customControls && e.media.setAttribute(\"tabindex\", -1), ve.call(e, e.media, \"timeupdate\"), ve.call(e, e.media, \"durationchange\"), clearInterval(e.timers.buffering), e.timers.buffering = setInterval(() => {\n                e.media.buffered = s.getVideoLoadedFraction(), (null === e.media.lastBuffered || e.media.lastBuffered < e.media.buffered) && ve.call(e, e.media, \"progress\"), e.media.lastBuffered = e.media.buffered, 1 === e.media.buffered && (clearInterval(e.timers.buffering), ve.call(e, e.media, \"canplaythrough\"));\n              }, 200), t.customControls && setTimeout(() => at.build.call(e), 50);\n            },\n            onStateChange(i) {\n              const s = i.target;\n              clearInterval(e.timers.playing);\n              switch (e.media.seeking && [1, 2].includes(i.data) && (e.media.seeking = !1, ve.call(e, e.media, \"seeked\")), i.data) {\n                case -1:\n                  ve.call(e, e.media, \"timeupdate\"), e.media.buffered = s.getVideoLoadedFraction(), ve.call(e, e.media, \"progress\");\n                  break;\n                case 0:\n                  ut.call(e, !1), e.media.loop ? (s.stopVideo(), s.playVideo()) : ve.call(e, e.media, \"ended\");\n                  break;\n                case 1:\n                  t.customControls && !e.config.autoplay && e.media.paused && !e.embed.hasPlayed ? e.media.pause() : (ut.call(e, !0), ve.call(e, e.media, \"playing\"), e.timers.playing = setInterval(() => {\n                    ve.call(e, e.media, \"timeupdate\");\n                  }, 50), e.media.duration !== s.getDuration() && (e.media.duration = s.getDuration(), ve.call(e, e.media, \"durationchange\")));\n                  break;\n                case 2:\n                  e.muted || e.embed.unMute(), ut.call(e, !1);\n                  break;\n                case 3:\n                  ve.call(e, e.media, \"waiting\");\n              }\n              ve.call(e, e.elements.container, \"statechange\", !1, {\n                code: i.data\n              });\n            }\n          }\n        });\n      }\n    },\n    pt = {\n      setup() {\n        this.media ? (le(this.elements.container, this.config.classNames.type.replace(\"{0}\", this.type), !0), le(this.elements.container, this.config.classNames.provider.replace(\"{0}\", this.provider), !0), this.isEmbed && le(this.elements.container, this.config.classNames.type.replace(\"{0}\", \"video\"), !0), this.isVideo && (this.elements.wrapper = Z(\"div\", {\n          class: this.config.classNames.video\n        }), J(this.media, this.elements.wrapper), this.elements.poster = Z(\"div\", {\n          class: this.config.classNames.poster\n        }), this.elements.wrapper.appendChild(this.elements.poster)), this.isHTML5 ? Le.setup.call(this) : this.isYouTube ? mt.setup.call(this) : this.isVimeo && ht.setup.call(this)) : this.debug.warn(\"No media element found!\");\n      }\n    };\n  class gt {\n    constructor(t) {\n      e(this, \"load\", () => {\n        this.enabled && (L(window.google) && L(window.google.ima) ? this.ready() : rt(this.player.config.urls.googleIMA.sdk).then(() => {\n          this.ready();\n        }).catch(() => {\n          this.trigger(\"error\", new Error(\"Google IMA SDK failed to load\"));\n        }));\n      }), e(this, \"ready\", () => {\n        var e;\n        this.enabled || ((e = this).manager && e.manager.destroy(), e.elements.displayContainer && e.elements.displayContainer.destroy(), e.elements.container.remove()), this.startSafetyTimer(12e3, \"ready()\"), this.managerPromise.then(() => {\n          this.clearSafetyTimer(\"onAdsManagerLoaded()\");\n        }), this.listeners(), this.setupIMA();\n      }), e(this, \"setupIMA\", () => {\n        this.elements.container = Z(\"div\", {\n          class: this.player.config.classNames.ads\n        }), this.player.elements.container.appendChild(this.elements.container), google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED), google.ima.settings.setLocale(this.player.config.ads.language), google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline), this.elements.displayContainer = new google.ima.AdDisplayContainer(this.elements.container, this.player.media), this.loader = new google.ima.AdsLoader(this.elements.displayContainer), this.loader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, e => this.onAdsManagerLoaded(e), !1), this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, e => this.onAdError(e), !1), this.requestAds();\n      }), e(this, \"requestAds\", () => {\n        const {\n          container: e\n        } = this.player.elements;\n        try {\n          const t = new google.ima.AdsRequest();\n          t.adTagUrl = this.tagUrl, t.linearAdSlotWidth = e.offsetWidth, t.linearAdSlotHeight = e.offsetHeight, t.nonLinearAdSlotWidth = e.offsetWidth, t.nonLinearAdSlotHeight = e.offsetHeight, t.forceNonLinearFullSlot = !1, t.setAdWillPlayMuted(!this.player.muted), this.loader.requestAds(t);\n        } catch (e) {\n          this.onAdError(e);\n        }\n      }), e(this, \"pollCountdown\", (e = !1) => {\n        if (!e) return clearInterval(this.countdownTimer), void this.elements.container.removeAttribute(\"data-badge-text\");\n        this.countdownTimer = setInterval(() => {\n          const e = Ue(Math.max(this.manager.getRemainingTime(), 0)),\n            t = `${He.get(\"advertisement\", this.player.config)} - ${e}`;\n          this.elements.container.setAttribute(\"data-badge-text\", t);\n        }, 100);\n      }), e(this, \"onAdsManagerLoaded\", e => {\n        if (!this.enabled) return;\n        const t = new google.ima.AdsRenderingSettings();\n        t.restoreCustomPlaybackStateOnAdBreakComplete = !0, t.enablePreloading = !0, this.manager = e.getAdsManager(this.player, t), this.cuePoints = this.manager.getCuePoints(), this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, e => this.onAdError(e)), Object.keys(google.ima.AdEvent.Type).forEach(e => {\n          this.manager.addEventListener(google.ima.AdEvent.Type[e], e => this.onAdEvent(e));\n        }), this.trigger(\"loaded\");\n      }), e(this, \"addCuePoints\", () => {\n        W(this.cuePoints) || this.cuePoints.forEach(e => {\n          if (0 !== e && -1 !== e && e < this.player.duration) {\n            const t = this.player.elements.progress;\n            if (H(t)) {\n              const i = 100 / this.player.duration * e,\n                s = Z(\"span\", {\n                  class: this.player.config.classNames.cues\n                });\n              s.style.left = `${i.toString()}%`, t.appendChild(s);\n            }\n          }\n        });\n      }), e(this, \"onAdEvent\", e => {\n        const {\n            container: t\n          } = this.player.elements,\n          i = e.getAd(),\n          s = e.getAdData();\n        switch ((e => {\n          ve.call(this.player, this.player.media, `ads${e.replace(/_/g, \"\").toLowerCase()}`);\n        })(e.type), e.type) {\n          case google.ima.AdEvent.Type.LOADED:\n            this.trigger(\"loaded\"), this.pollCountdown(!0), i.isLinear() || (i.width = t.offsetWidth, i.height = t.offsetHeight);\n            break;\n          case google.ima.AdEvent.Type.STARTED:\n            this.manager.setVolume(this.player.volume);\n            break;\n          case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:\n            this.player.ended ? this.loadAds() : this.loader.contentComplete();\n            break;\n          case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:\n            this.pauseContent();\n            break;\n          case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:\n            this.pollCountdown(), this.resumeContent();\n            break;\n          case google.ima.AdEvent.Type.LOG:\n            s.adError && this.player.debug.warn(`Non-fatal ad error: ${s.adError.getMessage()}`);\n        }\n      }), e(this, \"onAdError\", e => {\n        this.cancel(), this.player.debug.warn(\"Ads error\", e);\n      }), e(this, \"listeners\", () => {\n        const {\n          container: e\n        } = this.player.elements;\n        let t;\n        this.player.on(\"canplay\", () => {\n          this.addCuePoints();\n        }), this.player.on(\"ended\", () => {\n          this.loader.contentComplete();\n        }), this.player.on(\"timeupdate\", () => {\n          t = this.player.currentTime;\n        }), this.player.on(\"seeked\", () => {\n          const e = this.player.currentTime;\n          W(this.cuePoints) || this.cuePoints.forEach((i, s) => {\n            t < i && i < e && (this.manager.discardAdBreak(), this.cuePoints.splice(s, 1));\n          });\n        }), window.addEventListener(\"resize\", () => {\n          this.manager && this.manager.resize(e.offsetWidth, e.offsetHeight, google.ima.ViewMode.NORMAL);\n        });\n      }), e(this, \"play\", () => {\n        const {\n          container: e\n        } = this.player.elements;\n        this.managerPromise || this.resumeContent(), this.managerPromise.then(() => {\n          this.manager.setVolume(this.player.volume), this.elements.displayContainer.initialize();\n          try {\n            this.initialized || (this.manager.init(e.offsetWidth, e.offsetHeight, google.ima.ViewMode.NORMAL), this.manager.start()), this.initialized = !0;\n          } catch (e) {\n            this.onAdError(e);\n          }\n        }).catch(() => {});\n      }), e(this, \"resumeContent\", () => {\n        this.elements.container.style.zIndex = \"\", this.playing = !1, ke(this.player.media.play());\n      }), e(this, \"pauseContent\", () => {\n        this.elements.container.style.zIndex = 3, this.playing = !0, this.player.media.pause();\n      }), e(this, \"cancel\", () => {\n        this.initialized && this.resumeContent(), this.trigger(\"error\"), this.loadAds();\n      }), e(this, \"loadAds\", () => {\n        this.managerPromise.then(() => {\n          this.manager && this.manager.destroy(), this.managerPromise = new Promise(e => {\n            this.on(\"loaded\", e), this.player.debug.log(this.manager);\n          }), this.initialized = !1, this.requestAds();\n        }).catch(() => {});\n      }), e(this, \"trigger\", (e, ...t) => {\n        const i = this.events[e];\n        q(i) && i.forEach(e => {\n          j(e) && e.apply(this, t);\n        });\n      }), e(this, \"on\", (e, t) => (q(this.events[e]) || (this.events[e] = []), this.events[e].push(t), this)), e(this, \"startSafetyTimer\", (e, t) => {\n        this.player.debug.log(`Safety timer invoked from: ${t}`), this.safetyTimer = setTimeout(() => {\n          this.cancel(), this.clearSafetyTimer(\"startSafetyTimer()\");\n        }, e);\n      }), e(this, \"clearSafetyTimer\", e => {\n        I(this.safetyTimer) || (this.player.debug.log(`Safety timer cleared from: ${e}`), clearTimeout(this.safetyTimer), this.safetyTimer = null);\n      }), this.player = t, this.config = t.config.ads, this.playing = !1, this.initialized = !1, this.elements = {\n        container: null,\n        displayContainer: null\n      }, this.manager = null, this.loader = null, this.cuePoints = null, this.events = {}, this.safetyTimer = null, this.countdownTimer = null, this.managerPromise = new Promise((e, t) => {\n        this.on(\"loaded\", e), this.on(\"error\", t);\n      }), this.load();\n    }\n    get enabled() {\n      const {\n        config: e\n      } = this;\n      return this.player.isHTML5 && this.player.isVideo && e.enabled && (!W(e.publisherId) || U(e.tagUrl));\n    }\n    get tagUrl() {\n      const {\n        config: e\n      } = this;\n      if (U(e.tagUrl)) return e.tagUrl;\n      return `https://go.aniview.com/api/adserver6/vast/?${Ke({\n        AV_PUBLISHERID: \"58c25bb0073ef448b1087ad6\",\n        AV_CHANNELID: \"5a0458dc28a06145e4519d21\",\n        AV_URL: window.location.hostname,\n        cb: Date.now(),\n        AV_WIDTH: 640,\n        AV_HEIGHT: 480,\n        AV_CDIM2: e.publisherId\n      })}`;\n    }\n  }\n  const ft = e => {\n      const t = [];\n      return e.split(/\\r\\n\\r\\n|\\n\\n|\\r\\r/).forEach(e => {\n        const i = {};\n        e.split(/\\r\\n|\\n|\\r/).forEach(e => {\n          if ($(i.startTime)) {\n            if (!W(e.trim()) && W(i.text)) {\n              const t = e.trim().split(\"#xywh=\");\n              [i.text] = t, t[1] && ([i.x, i.y, i.w, i.h] = t[1].split(\",\"));\n            }\n          } else {\n            const t = e.match(/([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})( ?--> ?)([0-9]{2})?:?([0-9]{2}):([0-9]{2}).([0-9]{2,3})/);\n            t && (i.startTime = 60 * Number(t[1] || 0) * 60 + 60 * Number(t[2]) + Number(t[3]) + Number(`0.${t[4]}`), i.endTime = 60 * Number(t[6] || 0) * 60 + 60 * Number(t[7]) + Number(t[8]) + Number(`0.${t[9]}`));\n          }\n        }), i.text && t.push(i);\n      }), t;\n    },\n    bt = (e, t) => {\n      const i = {};\n      return e > t.width / t.height ? (i.width = t.width, i.height = 1 / e * t.width) : (i.height = t.height, i.width = e * t.height), i;\n    };\n  class yt {\n    constructor(t) {\n      e(this, \"load\", () => {\n        this.player.elements.display.seekTooltip && (this.player.elements.display.seekTooltip.hidden = this.enabled), this.enabled && this.getThumbnails().then(() => {\n          this.enabled && (this.render(), this.determineContainerAutoSizing(), this.loaded = !0);\n        });\n      }), e(this, \"getThumbnails\", () => new Promise(e => {\n        const {\n          src: t\n        } = this.player.config.previewThumbnails;\n        if (W(t)) throw new Error(\"Missing previewThumbnails.src config attribute\");\n        const i = () => {\n          this.thumbnails.sort((e, t) => e.height - t.height), this.player.debug.log(\"Preview thumbnails\", this.thumbnails), e();\n        };\n        if (j(t)) t(e => {\n          this.thumbnails = e, i();\n        });else {\n          const e = (_(t) ? [t] : t).map(e => this.getThumbnail(e));\n          Promise.all(e).then(i);\n        }\n      })), e(this, \"getThumbnail\", e => new Promise(t => {\n        Re(e).then(i => {\n          const s = {\n            frames: ft(i),\n            height: null,\n            urlPrefix: \"\"\n          };\n          s.frames[0].text.startsWith(\"/\") || s.frames[0].text.startsWith(\"http://\") || s.frames[0].text.startsWith(\"https://\") || (s.urlPrefix = e.substring(0, e.lastIndexOf(\"/\") + 1));\n          const n = new Image();\n          n.onload = () => {\n            s.height = n.naturalHeight, s.width = n.naturalWidth, this.thumbnails.push(s), t();\n          }, n.src = s.urlPrefix + s.frames[0].text;\n        });\n      })), e(this, \"startMove\", e => {\n        if (this.loaded && F(e) && [\"touchmove\", \"mousemove\"].includes(e.type) && this.player.media.duration) {\n          if (\"touchmove\" === e.type) this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100);else {\n            const t = this.player.elements.progress.getBoundingClientRect(),\n              i = 100 / t.width * (e.pageX - t.left);\n            this.seekTime = this.player.media.duration * (i / 100), this.seekTime < 0 && (this.seekTime = 0), this.seekTime > this.player.media.duration - 1 && (this.seekTime = this.player.media.duration - 1), this.mousePosX = e.pageX, this.elements.thumb.time.innerText = Ue(this.seekTime);\n          }\n          this.showImageAtCurrentTime();\n        }\n      }), e(this, \"endMove\", () => {\n        this.toggleThumbContainer(!1, !0);\n      }), e(this, \"startScrubbing\", e => {\n        (I(e.button) || !1 === e.button || 0 === e.button) && (this.mouseDown = !0, this.player.media.duration && (this.toggleScrubbingContainer(!0), this.toggleThumbContainer(!1, !0), this.showImageAtCurrentTime()));\n      }), e(this, \"endScrubbing\", () => {\n        this.mouseDown = !1, Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime) ? this.toggleScrubbingContainer(!1) : ye.call(this.player, this.player.media, \"timeupdate\", () => {\n          this.mouseDown || this.toggleScrubbingContainer(!1);\n        });\n      }), e(this, \"listeners\", () => {\n        this.player.on(\"play\", () => {\n          this.toggleThumbContainer(!1, !0);\n        }), this.player.on(\"seeked\", () => {\n          this.toggleThumbContainer(!1);\n        }), this.player.on(\"timeupdate\", () => {\n          this.lastTime = this.player.media.currentTime;\n        });\n      }), e(this, \"render\", () => {\n        this.elements.thumb.container = Z(\"div\", {\n          class: this.player.config.classNames.previewThumbnails.thumbContainer\n        }), this.elements.thumb.imageContainer = Z(\"div\", {\n          class: this.player.config.classNames.previewThumbnails.imageContainer\n        }), this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer);\n        const e = Z(\"div\", {\n          class: this.player.config.classNames.previewThumbnails.timeContainer\n        });\n        this.elements.thumb.time = Z(\"span\", {}, \"00:00\"), e.appendChild(this.elements.thumb.time), this.elements.thumb.container.appendChild(e), H(this.player.elements.progress) && this.player.elements.progress.appendChild(this.elements.thumb.container), this.elements.scrubbing.container = Z(\"div\", {\n          class: this.player.config.classNames.previewThumbnails.scrubbingContainer\n        }), this.player.elements.wrapper.appendChild(this.elements.scrubbing.container);\n      }), e(this, \"destroy\", () => {\n        this.elements.thumb.container && this.elements.thumb.container.remove(), this.elements.scrubbing.container && this.elements.scrubbing.container.remove();\n      }), e(this, \"showImageAtCurrentTime\", () => {\n        this.mouseDown ? this.setScrubbingContainerSize() : this.setThumbContainerSizeAndPos();\n        const e = this.thumbnails[0].frames.findIndex(e => this.seekTime >= e.startTime && this.seekTime <= e.endTime),\n          t = e >= 0;\n        let i = 0;\n        this.mouseDown || this.toggleThumbContainer(t), t && (this.thumbnails.forEach((t, s) => {\n          this.loadedImages.includes(t.frames[e].text) && (i = s);\n        }), e !== this.showingThumb && (this.showingThumb = e, this.loadImage(i)));\n      }), e(this, \"loadImage\", (e = 0) => {\n        const t = this.showingThumb,\n          i = this.thumbnails[e],\n          {\n            urlPrefix: s\n          } = i,\n          n = i.frames[t],\n          a = i.frames[t].text,\n          l = s + a;\n        if (this.currentImageElement && this.currentImageElement.dataset.filename === a) this.showImage(this.currentImageElement, n, e, t, a, !1), this.currentImageElement.dataset.index = t, this.removeOldImages(this.currentImageElement);else {\n          this.loadingImage && this.usingSprites && (this.loadingImage.onload = null);\n          const i = new Image();\n          i.src = l, i.dataset.index = t, i.dataset.filename = a, this.showingThumbFilename = a, this.player.debug.log(`Loading image: ${l}`), i.onload = () => this.showImage(i, n, e, t, a, !0), this.loadingImage = i, this.removeOldImages(i);\n        }\n      }), e(this, \"showImage\", (e, t, i, s, n, a = !0) => {\n        this.player.debug.log(`Showing thumb: ${n}. num: ${s}. qual: ${i}. newimg: ${a}`), this.setImageSizeAndOffset(e, t), a && (this.currentImageContainer.appendChild(e), this.currentImageElement = e, this.loadedImages.includes(n) || this.loadedImages.push(n)), this.preloadNearby(s, !0).then(this.preloadNearby(s, !1)).then(this.getHigherQuality(i, e, t, n));\n      }), e(this, \"removeOldImages\", e => {\n        Array.from(this.currentImageContainer.children).forEach(t => {\n          if (\"img\" !== t.tagName.toLowerCase()) return;\n          const i = this.usingSprites ? 500 : 1e3;\n          if (t.dataset.index !== e.dataset.index && !t.dataset.deleting) {\n            t.dataset.deleting = !0;\n            const {\n              currentImageContainer: e\n            } = this;\n            setTimeout(() => {\n              e.removeChild(t), this.player.debug.log(`Removing thumb: ${t.dataset.filename}`);\n            }, i);\n          }\n        });\n      }), e(this, \"preloadNearby\", (e, t = !0) => new Promise(i => {\n        setTimeout(() => {\n          const s = this.thumbnails[0].frames[e].text;\n          if (this.showingThumbFilename === s) {\n            let n;\n            n = t ? this.thumbnails[0].frames.slice(e) : this.thumbnails[0].frames.slice(0, e).reverse();\n            let a = !1;\n            n.forEach(e => {\n              const t = e.text;\n              if (t !== s && !this.loadedImages.includes(t)) {\n                a = !0, this.player.debug.log(`Preloading thumb filename: ${t}`);\n                const {\n                    urlPrefix: e\n                  } = this.thumbnails[0],\n                  s = e + t,\n                  n = new Image();\n                n.src = s, n.onload = () => {\n                  this.player.debug.log(`Preloaded thumb filename: ${t}`), this.loadedImages.includes(t) || this.loadedImages.push(t), i();\n                };\n              }\n            }), a || i();\n          }\n        }, 300);\n      })), e(this, \"getHigherQuality\", (e, t, i, s) => {\n        if (e < this.thumbnails.length - 1) {\n          let n = t.naturalHeight;\n          this.usingSprites && (n = i.h), n < this.thumbContainerHeight && setTimeout(() => {\n            this.showingThumbFilename === s && (this.player.debug.log(`Showing higher quality thumb for: ${s}`), this.loadImage(e + 1));\n          }, 300);\n        }\n      }), e(this, \"toggleThumbContainer\", (e = !1, t = !1) => {\n        const i = this.player.config.classNames.previewThumbnails.thumbContainerShown;\n        this.elements.thumb.container.classList.toggle(i, e), !e && t && (this.showingThumb = null, this.showingThumbFilename = null);\n      }), e(this, \"toggleScrubbingContainer\", (e = !1) => {\n        const t = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;\n        this.elements.scrubbing.container.classList.toggle(t, e), e || (this.showingThumb = null, this.showingThumbFilename = null);\n      }), e(this, \"determineContainerAutoSizing\", () => {\n        (this.elements.thumb.imageContainer.clientHeight > 20 || this.elements.thumb.imageContainer.clientWidth > 20) && (this.sizeSpecifiedInCSS = !0);\n      }), e(this, \"setThumbContainerSizeAndPos\", () => {\n        if (this.sizeSpecifiedInCSS) {\n          if (this.elements.thumb.imageContainer.clientHeight > 20 && this.elements.thumb.imageContainer.clientWidth < 20) {\n            const e = Math.floor(this.elements.thumb.imageContainer.clientHeight * this.thumbAspectRatio);\n            this.elements.thumb.imageContainer.style.width = `${e}px`;\n          } else if (this.elements.thumb.imageContainer.clientHeight < 20 && this.elements.thumb.imageContainer.clientWidth > 20) {\n            const e = Math.floor(this.elements.thumb.imageContainer.clientWidth / this.thumbAspectRatio);\n            this.elements.thumb.imageContainer.style.height = `${e}px`;\n          }\n        } else {\n          const e = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio);\n          this.elements.thumb.imageContainer.style.height = `${this.thumbContainerHeight}px`, this.elements.thumb.imageContainer.style.width = `${e}px`;\n        }\n        this.setThumbContainerPos();\n      }), e(this, \"setThumbContainerPos\", () => {\n        const e = this.player.elements.progress.getBoundingClientRect(),\n          t = this.player.elements.container.getBoundingClientRect(),\n          {\n            container: i\n          } = this.elements.thumb,\n          s = t.left - e.left + 10,\n          n = t.right - e.left - i.clientWidth - 10;\n        let a = this.mousePosX - e.left - i.clientWidth / 2;\n        a < s && (a = s), a > n && (a = n), i.style.left = `${a}px`;\n      }), e(this, \"setScrubbingContainerSize\", () => {\n        const {\n          width: e,\n          height: t\n        } = bt(this.thumbAspectRatio, {\n          width: this.player.media.clientWidth,\n          height: this.player.media.clientHeight\n        });\n        this.elements.scrubbing.container.style.width = `${e}px`, this.elements.scrubbing.container.style.height = `${t}px`;\n      }), e(this, \"setImageSizeAndOffset\", (e, t) => {\n        if (!this.usingSprites) return;\n        const i = this.thumbContainerHeight / t.h;\n        e.style.height = e.naturalHeight * i + \"px\", e.style.width = e.naturalWidth * i + \"px\", e.style.left = `-${t.x * i}px`, e.style.top = `-${t.y * i}px`;\n      }), this.player = t, this.thumbnails = [], this.loaded = !1, this.lastMouseMoveTime = Date.now(), this.mouseDown = !1, this.loadedImages = [], this.elements = {\n        thumb: {},\n        scrubbing: {}\n      }, this.load();\n    }\n    get enabled() {\n      return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled;\n    }\n    get currentImageContainer() {\n      return this.mouseDown ? this.elements.scrubbing.container : this.elements.thumb.imageContainer;\n    }\n    get usingSprites() {\n      return Object.keys(this.thumbnails[0].frames[0]).includes(\"w\");\n    }\n    get thumbAspectRatio() {\n      return this.usingSprites ? this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h : this.thumbnails[0].width / this.thumbnails[0].height;\n    }\n    get thumbContainerHeight() {\n      if (this.mouseDown) {\n        const {\n          height: e\n        } = bt(this.thumbAspectRatio, {\n          width: this.player.media.clientWidth,\n          height: this.player.media.clientHeight\n        });\n        return e;\n      }\n      return this.sizeSpecifiedInCSS ? this.elements.thumb.imageContainer.clientHeight : Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4);\n    }\n    get currentImageElement() {\n      return this.mouseDown ? this.currentScrubbingImageElement : this.currentThumbnailImageElement;\n    }\n    set currentImageElement(e) {\n      this.mouseDown ? this.currentScrubbingImageElement = e : this.currentThumbnailImageElement = e;\n    }\n  }\n  const vt = {\n    insertElements(e, t) {\n      _(t) ? ee(e, this.media, {\n        src: t\n      }) : q(t) && t.forEach(t => {\n        ee(e, this.media, t);\n      });\n    },\n    change(e) {\n      Q(e, \"sources.length\") ? (Le.cancelRequests.call(this), this.destroy.call(this, () => {\n        this.options.quality = [], te(this.media), this.media = null, H(this.elements.container) && this.elements.container.removeAttribute(\"class\");\n        const {\n            sources: t,\n            type: i\n          } = e,\n          [{\n            provider: s = Ge.html5,\n            src: n\n          }] = t,\n          a = \"html5\" === s ? i : \"div\",\n          l = \"html5\" === s ? {} : {\n            src: n\n          };\n        Object.assign(this, {\n          provider: s,\n          type: i,\n          supported: me.check(i, s, this.config.playsinline),\n          media: Z(a, l)\n        }), this.elements.container.appendChild(this.media), O(e.autoplay) && (this.config.autoplay = e.autoplay), this.isHTML5 && (this.config.crossorigin && this.media.setAttribute(\"crossorigin\", \"\"), this.config.autoplay && this.media.setAttribute(\"autoplay\", \"\"), W(e.poster) || (this.poster = e.poster), this.config.loop.active && this.media.setAttribute(\"loop\", \"\"), this.config.muted && this.media.setAttribute(\"muted\", \"\"), this.config.playsinline && this.media.setAttribute(\"playsinline\", \"\")), at.addStyleHook.call(this), this.isHTML5 && vt.insertElements.call(this, \"source\", t), this.config.title = e.title, pt.setup.call(this), this.isHTML5 && Object.keys(e).includes(\"tracks\") && vt.insertElements.call(this, \"track\", e.tracks), (this.isHTML5 || this.isEmbed && !this.supported.ui) && at.build.call(this), this.isHTML5 && this.media.load(), W(e.previewThumbnails) || (Object.assign(this.config.previewThumbnails, e.previewThumbnails), this.previewThumbnails && this.previewThumbnails.loaded && (this.previewThumbnails.destroy(), this.previewThumbnails = null), this.config.previewThumbnails.enabled && (this.previewThumbnails = new yt(this))), this.fullscreen.update();\n      }, !0)) : this.debug.warn(\"Invalid source format\");\n    }\n  };\n  class wt {\n    constructor(t, i) {\n      if (e(this, \"play\", () => j(this.media.play) ? (this.ads && this.ads.enabled && this.ads.managerPromise.then(() => this.ads.play()).catch(() => ke(this.media.play())), this.media.play()) : null), e(this, \"pause\", () => this.playing && j(this.media.pause) ? this.media.pause() : null), e(this, \"togglePlay\", e => (O(e) ? e : !this.playing) ? this.play() : this.pause()), e(this, \"stop\", () => {\n        this.isHTML5 ? (this.pause(), this.restart()) : j(this.media.stop) && this.media.stop();\n      }), e(this, \"restart\", () => {\n        this.currentTime = 0;\n      }), e(this, \"rewind\", e => {\n        this.currentTime -= $(e) ? e : this.config.seekTime;\n      }), e(this, \"forward\", e => {\n        this.currentTime += $(e) ? e : this.config.seekTime;\n      }), e(this, \"increaseVolume\", e => {\n        const t = this.media.muted ? 0 : this.volume;\n        this.volume = t + ($(e) ? e : 0);\n      }), e(this, \"decreaseVolume\", e => {\n        this.increaseVolume(-e);\n      }), e(this, \"airplay\", () => {\n        me.airplay && this.media.webkitShowPlaybackTargetPicker();\n      }), e(this, \"toggleControls\", e => {\n        if (this.supported.ui && !this.isAudio) {\n          const t = oe(this.elements.container, this.config.classNames.hideControls),\n            i = void 0 === e ? void 0 : !e,\n            s = le(this.elements.container, this.config.classNames.hideControls, i);\n          if (s && q(this.config.controls) && this.config.controls.includes(\"settings\") && !W(this.config.settings) && We.toggleMenu.call(this, !1), s !== t) {\n            const e = s ? \"controlshidden\" : \"controlsshown\";\n            ve.call(this, this.media, e);\n          }\n          return !s;\n        }\n        return !1;\n      }), e(this, \"on\", (e, t) => {\n        fe.call(this, this.elements.container, e, t);\n      }), e(this, \"once\", (e, t) => {\n        ye.call(this, this.elements.container, e, t);\n      }), e(this, \"off\", (e, t) => {\n        be(this.elements.container, e, t);\n      }), e(this, \"destroy\", (e, t = !1) => {\n        if (!this.ready) return;\n        const i = () => {\n          document.body.style.overflow = \"\", this.embed = null, t ? (Object.keys(this.elements).length && (te(this.elements.buttons.play), te(this.elements.captions), te(this.elements.controls), te(this.elements.wrapper), this.elements.buttons.play = null, this.elements.captions = null, this.elements.controls = null, this.elements.wrapper = null), j(e) && e()) : (we.call(this), Le.cancelRequests.call(this), se(this.elements.original, this.elements.container), ve.call(this, this.elements.original, \"destroyed\", !0), j(e) && e.call(this.elements.original), this.ready = !1, setTimeout(() => {\n            this.elements = null, this.media = null;\n          }, 200));\n        };\n        this.stop(), clearTimeout(this.timers.loading), clearTimeout(this.timers.controls), clearTimeout(this.timers.resized), this.isHTML5 ? (at.toggleNativeControls.call(this, !0), i()) : this.isYouTube ? (clearInterval(this.timers.buffering), clearInterval(this.timers.playing), null !== this.embed && j(this.embed.destroy) && this.embed.destroy(), i()) : this.isVimeo && (null !== this.embed && this.embed.unload().then(i), setTimeout(i, 200));\n      }), e(this, \"supports\", e => me.mime.call(this, e)), this.timers = {}, this.ready = !1, this.loading = !1, this.failed = !1, this.touch = me.touch, this.media = t, _(this.media) && (this.media = document.querySelectorAll(this.media)), (window.jQuery && this.media instanceof jQuery || D(this.media) || q(this.media)) && (this.media = this.media[0]), this.config = X({}, Qe, wt.defaults, i || {}, (() => {\n        try {\n          return JSON.parse(this.media.getAttribute(\"data-plyr-config\"));\n        } catch (e) {\n          return {};\n        }\n      })()), this.elements = {\n        container: null,\n        fullscreen: null,\n        captions: null,\n        buttons: {},\n        display: {},\n        progress: {},\n        inputs: {},\n        settings: {\n          popup: null,\n          menu: null,\n          panels: {},\n          buttons: {}\n        }\n      }, this.captions = {\n        active: null,\n        currentTrack: -1,\n        meta: new WeakMap()\n      }, this.fullscreen = {\n        active: !1\n      }, this.options = {\n        speed: [],\n        quality: []\n      }, this.debug = new it(this.config.debug), this.debug.log(\"Config\", this.config), this.debug.log(\"Support\", me), I(this.media) || !H(this.media)) return void this.debug.error(\"Setup failed: no suitable element passed\");\n      if (this.media.plyr) return void this.debug.warn(\"Target already setup\");\n      if (!this.config.enabled) return void this.debug.error(\"Setup failed: disabled by config\");\n      if (!me.check().api) return void this.debug.error(\"Setup failed: no support\");\n      const s = this.media.cloneNode(!0);\n      s.autoplay = !1, this.elements.original = s;\n      const n = this.media.tagName.toLowerCase();\n      let a = null,\n        l = null;\n      switch (n) {\n        case \"div\":\n          if (a = this.media.querySelector(\"iframe\"), H(a)) {\n            if (l = ze(a.getAttribute(\"src\")), this.provider = function (e) {\n              return /^(https?:\\/\\/)?(www\\.)?(youtube\\.com|youtube-nocookie\\.com|youtu\\.?be)\\/.+$/.test(e) ? Ge.youtube : /^https?:\\/\\/player.vimeo.com\\/video\\/\\d{0,9}(?=\\b|\\/)/.test(e) ? Ge.vimeo : null;\n            }(l.toString()), this.elements.container = this.media, this.media = a, this.elements.container.className = \"\", l.search.length) {\n              const e = [\"1\", \"true\"];\n              e.includes(l.searchParams.get(\"autoplay\")) && (this.config.autoplay = !0), e.includes(l.searchParams.get(\"loop\")) && (this.config.loop.active = !0), this.isYouTube ? (this.config.playsinline = e.includes(l.searchParams.get(\"playsinline\")), this.config.youtube.hl = l.searchParams.get(\"hl\")) : this.config.playsinline = !0;\n            }\n          } else this.provider = this.media.getAttribute(this.config.attributes.embed.provider), this.media.removeAttribute(this.config.attributes.embed.provider);\n          if (W(this.provider) || !Object.values(Ge).includes(this.provider)) return void this.debug.error(\"Setup failed: Invalid provider\");\n          this.type = et;\n          break;\n        case \"video\":\n        case \"audio\":\n          this.type = n, this.provider = Ge.html5, this.media.hasAttribute(\"crossorigin\") && (this.config.crossorigin = !0), this.media.hasAttribute(\"autoplay\") && (this.config.autoplay = !0), (this.media.hasAttribute(\"playsinline\") || this.media.hasAttribute(\"webkit-playsinline\")) && (this.config.playsinline = !0), this.media.hasAttribute(\"muted\") && (this.config.muted = !0), this.media.hasAttribute(\"loop\") && (this.config.loop.active = !0);\n          break;\n        default:\n          return void this.debug.error(\"Setup failed: unsupported type\");\n      }\n      this.supported = me.check(this.type, this.provider, this.config.playsinline), this.supported.api ? (this.eventListeners = [], this.listeners = new lt(this), this.storage = new Fe(this), this.media.plyr = this, H(this.elements.container) || (this.elements.container = Z(\"div\", {\n        tabindex: 0\n      }), J(this.media, this.elements.container)), at.migrateStyles.call(this), at.addStyleHook.call(this), pt.setup.call(this), this.config.debug && fe.call(this, this.elements.container, this.config.events.join(\" \"), e => {\n        this.debug.log(`event: ${e.type}`);\n      }), this.fullscreen = new st(this), (this.isHTML5 || this.isEmbed && !this.supported.ui) && at.build.call(this), this.listeners.container(), this.listeners.global(), this.config.ads.enabled && (this.ads = new gt(this)), this.isHTML5 && this.config.autoplay && this.once(\"canplay\", () => ke(this.play())), this.lastSeekTime = 0, this.config.previewThumbnails.enabled && (this.previewThumbnails = new yt(this))) : this.debug.error(\"Setup failed: no support\");\n    }\n    get isHTML5() {\n      return this.provider === Ge.html5;\n    }\n    get isEmbed() {\n      return this.isYouTube || this.isVimeo;\n    }\n    get isYouTube() {\n      return this.provider === Ge.youtube;\n    }\n    get isVimeo() {\n      return this.provider === Ge.vimeo;\n    }\n    get isVideo() {\n      return this.type === et;\n    }\n    get isAudio() {\n      return this.type === Ze;\n    }\n    get playing() {\n      return Boolean(this.ready && !this.paused && !this.ended);\n    }\n    get paused() {\n      return Boolean(this.media.paused);\n    }\n    get stopped() {\n      return Boolean(this.paused && 0 === this.currentTime);\n    }\n    get ended() {\n      return Boolean(this.media.ended);\n    }\n    set currentTime(e) {\n      if (!this.duration) return;\n      const t = $(e) && e > 0;\n      this.media.currentTime = t ? Math.min(e, this.duration) : 0, this.debug.log(`Seeking to ${this.currentTime} seconds`);\n    }\n    get currentTime() {\n      return Number(this.media.currentTime);\n    }\n    get buffered() {\n      const {\n        buffered: e\n      } = this.media;\n      return $(e) ? e : e && e.length && this.duration > 0 ? e.end(0) / this.duration : 0;\n    }\n    get seeking() {\n      return Boolean(this.media.seeking);\n    }\n    get duration() {\n      const e = parseFloat(this.config.duration),\n        t = (this.media || {}).duration,\n        i = $(t) && t !== 1 / 0 ? t : 0;\n      return e || i;\n    }\n    set volume(e) {\n      let t = e;\n      _(t) && (t = Number(t)), $(t) || (t = this.storage.get(\"volume\")), $(t) || ({\n        volume: t\n      } = this.config), t > 1 && (t = 1), t < 0 && (t = 0), this.config.volume = t, this.media.volume = t, !W(e) && this.muted && t > 0 && (this.muted = !1);\n    }\n    get volume() {\n      return Number(this.media.volume);\n    }\n    set muted(e) {\n      let t = e;\n      O(t) || (t = this.storage.get(\"muted\")), O(t) || (t = this.config.muted), this.config.muted = t, this.media.muted = t;\n    }\n    get muted() {\n      return Boolean(this.media.muted);\n    }\n    get hasAudio() {\n      return !this.isHTML5 || !!this.isAudio || Boolean(this.media.mozHasAudio) || Boolean(this.media.webkitAudioDecodedByteCount) || Boolean(this.media.audioTracks && this.media.audioTracks.length);\n    }\n    set speed(e) {\n      let t = null;\n      $(e) && (t = e), $(t) || (t = this.storage.get(\"speed\")), $(t) || (t = this.config.speed.selected);\n      const {\n        minimumSpeed: i,\n        maximumSpeed: s\n      } = this;\n      t = function (e = 0, t = 0, i = 255) {\n        return Math.min(Math.max(e, t), i);\n      }(t, i, s), this.config.speed.selected = t, setTimeout(() => {\n        this.media && (this.media.playbackRate = t);\n      }, 0);\n    }\n    get speed() {\n      return Number(this.media.playbackRate);\n    }\n    get minimumSpeed() {\n      return this.isYouTube ? Math.min(...this.options.speed) : this.isVimeo ? .5 : .0625;\n    }\n    get maximumSpeed() {\n      return this.isYouTube ? Math.max(...this.options.speed) : this.isVimeo ? 2 : 16;\n    }\n    set quality(e) {\n      const t = this.config.quality,\n        i = this.options.quality;\n      if (!i.length) return;\n      let s = [!W(e) && Number(e), this.storage.get(\"quality\"), t.selected, t.default].find($),\n        n = !0;\n      if (!i.includes(s)) {\n        const e = Ae(i, s);\n        this.debug.warn(`Unsupported quality option: ${s}, using ${e} instead`), s = e, n = !1;\n      }\n      t.selected = s, this.media.quality = s, n && this.storage.set({\n        quality: s\n      });\n    }\n    get quality() {\n      return this.media.quality;\n    }\n    set loop(e) {\n      const t = O(e) ? e : this.config.loop.active;\n      this.config.loop.active = t, this.media.loop = t;\n    }\n    get loop() {\n      return Boolean(this.media.loop);\n    }\n    set source(e) {\n      vt.change.call(this, e);\n    }\n    get source() {\n      return this.media.currentSrc;\n    }\n    get download() {\n      const {\n        download: e\n      } = this.config.urls;\n      return U(e) ? e : this.source;\n    }\n    set download(e) {\n      U(e) && (this.config.urls.download = e, We.setDownloadUrl.call(this));\n    }\n    set poster(e) {\n      this.isVideo ? at.setPoster.call(this, e, !1).catch(() => {}) : this.debug.warn(\"Poster can only be set for video\");\n    }\n    get poster() {\n      return this.isVideo ? this.media.getAttribute(\"poster\") || this.media.getAttribute(\"data-poster\") : null;\n    }\n    get ratio() {\n      if (!this.isVideo) return null;\n      const e = Ne(xe.call(this));\n      return q(e) ? e.join(\":\") : e;\n    }\n    set ratio(e) {\n      this.isVideo ? _(e) && Pe(e) ? (this.config.ratio = Ne(e), Me.call(this)) : this.debug.error(`Invalid aspect ratio specified (${e})`) : this.debug.warn(\"Aspect ratio can only be set for video\");\n    }\n    set autoplay(e) {\n      const t = O(e) ? e : this.config.autoplay;\n      this.config.autoplay = t;\n    }\n    get autoplay() {\n      return Boolean(this.config.autoplay);\n    }\n    toggleCaptions(e) {\n      Ye.toggle.call(this, e, !1);\n    }\n    set currentTrack(e) {\n      Ye.set.call(this, e, !1), Ye.setup();\n    }\n    get currentTrack() {\n      const {\n        toggled: e,\n        currentTrack: t\n      } = this.captions;\n      return e ? t : -1;\n    }\n    set language(e) {\n      Ye.setLanguage.call(this, e, !1);\n    }\n    get language() {\n      return (Ye.getCurrentTrack.call(this) || {}).language;\n    }\n    set pip(e) {\n      if (!me.pip) return;\n      const t = O(e) ? e : !this.pip;\n      j(this.media.webkitSetPresentationMode) && this.media.webkitSetPresentationMode(t ? Xe : Je), j(this.media.requestPictureInPicture) && (!this.pip && t ? this.media.requestPictureInPicture() : this.pip && !t && document.exitPictureInPicture());\n    }\n    get pip() {\n      return me.pip ? W(this.media.webkitPresentationMode) ? this.media === document.pictureInPictureElement : this.media.webkitPresentationMode === Xe : null;\n    }\n    setPreviewThumbnails(e) {\n      this.previewThumbnails && this.previewThumbnails.loaded && (this.previewThumbnails.destroy(), this.previewThumbnails = null), Object.assign(this.config.previewThumbnails, e), this.config.previewThumbnails.enabled && (this.previewThumbnails = new yt(this));\n    }\n    static supported(e, t, i) {\n      return me.check(e, t, i);\n    }\n    static loadSprite(e, t) {\n      return Ve(e, t);\n    }\n    static setup(e, t = {}) {\n      let i = null;\n      return _(e) ? i = Array.from(document.querySelectorAll(e)) : D(e) ? i = Array.from(e) : q(e) && (i = e.filter(H)), W(i) ? null : i.map(e => new wt(e, t));\n    }\n  }\n  var Tt;\n  return wt.defaults = (Tt = Qe, JSON.parse(JSON.stringify(Tt))), wt;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/plyr/dist/plyr.min.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = function () {\n  return this;\n}();\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function(\"return this\")();\n} catch (e) {\n  // This works if the window reference is available\n  if (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ })

/******/ });